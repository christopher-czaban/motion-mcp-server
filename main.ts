console.error(`[MCP Server main.ts] Starting execution at ${new Date().toISOString()}`);
console.error(`[MCP Server main.ts] Node version: ${process.version}`);

/**
 * Generated by spectomcp.updab.com
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { z } from 'zod';
import './database.js'; // Ensures database is initialized on startup
import rateLimiter from './rate_limiter.js'; 
import { zodToJsonSchema } from 'zod-to-json-schema';

// Prune old records on server startup
try {
  rateLimiter.pruneOldRecords(Date.now());
  console.error('[RateLimiter] Successfully pruned old records on startup.');
} catch (error) {
  console.error('[RateLimiter] Error pruning old records on startup:', error);
  // Depending on policy, might want to re-throw or handle differently
}

// Rate Limiting Constants
const MAX_CALLS = 12;
const TIME_WINDOW_MS = 180000; // 3 minutes in milliseconds
const LOG_PRUNE_AFTER_MS = 600000; // 10 minutes in milliseconds

let baseUrl = 'https://api.usemotion.com/v1'; // Base URL from Swagger spec or default

// Helper function to retrieve a value from an object using a dot-notation path
function getValueByPath(obj: any, path: string): { value: any; found: boolean } {
  if (obj === null || obj === undefined || typeof obj !== 'object' || !path) {
    return { value: undefined, found: false };
  }
  const parts = path.split('.');
  let current = obj;
  for (const part of parts) {
    if (current === null || current === undefined || typeof current !== 'object' || !Object.prototype.hasOwnProperty.call(current, part)) {
      return { value: undefined, found: false };
    }
    current = current[part];
  }
  return { value: current, found: true };
}

// Utility function to format a date string to YYYY-MM-DD
// Returns original string if parsing fails or input is invalid, or null if input is null/undefined.
function formatDateToYYYYMMDD(dateString: string | null | undefined): string | null {
  if (dateString === null || dateString === undefined) {
    return null;
  }
  try {
    // Check if it's already in YYYY-MM-DD format to avoid re-processing
    if (/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
      return dateString;
    }
    const date = new Date(dateString);
    // Check if date is valid after parsing
    if (isNaN(date.getTime())) {
      return dateString; // Return original if invalid date string
    }
    return date.toISOString().split('T')[0];
  } catch (e) {
    // In case of any other error during parsing or processing
    return dateString; // Return original string on error as per PRD nuance
  }
}

// Utility function to format specific date fields within an object to YYYY-MM-DD
// Modifies the object in place if a field is found and validly formatted, 
// otherwise leaves it as is or as formatted by formatDateToYYYYMMDD (which can return original on error).
function formatObjectDates(obj: any, dateFieldPaths: string[]): void {
  if (!obj || typeof obj !== 'object' || !dateFieldPaths || dateFieldPaths.length === 0) {
    return; // No object or no fields to process
  }

  for (const path of dateFieldPaths) {
    let current = obj;
    const parts = path.split('.');
    const lastPart = parts.pop(); // Get the actual field name and remove it from parts

    if (!lastPart) continue; // Should not happen with valid paths

    // Navigate to the parent of the target field
    let parent = obj;
    for (const part of parts) {
      if (parent && typeof parent === 'object' && Object.prototype.hasOwnProperty.call(parent, part)) {
        parent = parent[part];
      } else {
        parent = null; // Path is invalid or part not found
        break;
      }
    }

    // If parent is valid and has the target field, format it
    if (parent && typeof parent === 'object' && Object.prototype.hasOwnProperty.call(parent, lastPart)) {
      const originalValue = parent[lastPart];
      const formattedDate = formatDateToYYYYMMDD(originalValue);
      // formatDateToYYYYMMDD returns original on error/invalid, or null if input was null.
      // We only update if it makes sense (e.g. if formatDateToYYYYMMDD actually changed it or it was null)
      if (formattedDate !== originalValue || originalValue === null) { 
        parent[lastPart] = formattedDate;
      }
    }
  }
}

// Helper function to process a single object based on specified fields and rules
function _processSingleObjectInternal(
  obj: any,
  fieldsToSelect: string[],
  // toolSpecificRules will be used in later subtasks
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  toolSpecificRules?: Record<string, any>,
  isDefaultMode?: boolean // Added for Subtask 1.3
): any {
  if (obj === null || obj === undefined || typeof obj !== 'object') {
    return {}; // Or null, depending on desired behavior for non-objects
  }
  const result: Record<string, any> = {};
  for (const fieldPath of fieldsToSelect) {
    let currentValue: any;
    let isValidField: boolean = false;

    // MODIFICATION FOR SUBTASK 1.2:
    if (fieldPath.includes('.')) {
      const { value, found } = getValueByPath(obj, fieldPath);
      if (found) {
        currentValue = value; // Store for further processing
        isValidField = true;
      } else {
        // Optionally set to null if not found, or omit. PRD implies omitting or standard error later.
        // For now, let's omit if not found to keep responses clean.
        isValidField = false;
      }
    } else if (Object.prototype.hasOwnProperty.call(obj, fieldPath)) {
      currentValue = obj[fieldPath]; // Store for further processing
      isValidField = true;
    } else {
      isValidField = false;
    }

    if (isValidField) {
      if (Array.isArray(currentValue)) {
        const itemSimplificationRule = toolSpecificRules?.[fieldPath]?.defaultItemSimplification;
        
        // Apply itemSimplificationRule if it exists, regardless of isDefaultMode, 
        // when the array field itself (fieldPath) is being processed.
        // This handles cases like PRD 2.3's "simplified optional" for assignees.
        if (typeof itemSimplificationRule === 'function') {
          try {
            result[fieldPath] = currentValue.map(itemSimplificationRule);
          } catch (e) {
            console.error(`Error applying itemSimplificationRule for field '${fieldPath}':`, e);
            result[fieldPath] = currentValue; // Fallback to full array on rule error
          }
        } else {
          // No specific simplification rule for this array field (or it was handled by fields like array[].property).
          // If !isDefaultMode, PRD 1.3.3 (return full array) applies unless a rule handled it.
          // If isDefaultMode and no rule, also return full array (e.g. array of primitives).
          result[fieldPath] = currentValue; 
        }
      } else if (typeof currentValue === 'object' && currentValue !== null && !isDefaultMode) {
        // Optional Mode for an object field, check for container simplification (PRD 1.3.1)
        const containerRule = toolSpecificRules?.[fieldPath]?.optionalContainerSimplification;
        if (typeof containerRule === 'function') {
          try {
            const simplifiedObject = containerRule(currentValue);
            Object.assign(result, simplifiedObject); // Merge properties from rule output
          } catch (e) {
            console.error(`Error applying optionalContainerSimplification for field '${fieldPath}':`, e);
            // If rule fails, the original object might still be added if fieldPath was directly requested
            // and no other rule applies. This part handles the rule itself failing.
            // If fieldPath was a direct request (e.g. fields:["manager"]) and rule fails,
            // it will fall through to the general 'else' block below if not already handled.
            // To ensure it doesn't get added again by the generic logic if the rule was the SOLE source for these fields:
            // We can check if result[fieldPath] was already set OR if the rule was supposed to be the exclusive handler for this fieldPath.
            // For now, the Object.assign is simply skipped. If the fieldPath itself was requested, it might be added by the generic handler later.
            // This behavior might need refinement based on how strictly PRD 1.3.1 should be interpreted on rule failure.
          }
        } else {
          // Optional mode, object, but no specific container simplification rule.
          result[fieldPath] = currentValue;
        }
      } else {
        // Primitive value, or an object in default mode (no special container simplification for objects in default mode by default)
        result[fieldPath] = currentValue;
      }
    }
  }
  // Apply post-processing rules after all fields are initially populated
  for (const fieldKey in result) {
    if (Object.prototype.hasOwnProperty.call(result, fieldKey)) {
      const postProcessRule = toolSpecificRules?.[fieldKey]?.postProcessField;
      if (typeof postProcessRule === 'function') {
        try {
          result[fieldKey] = postProcessRule(result[fieldKey]);
        } catch (e) {
          console.error(`Error applying postProcessField for field '${fieldKey}':`, e);
          // On error, leave the original selected value in place
        }
      }
    }
  }
  return result;
}

// Main utility function to select and transform fields from data
function selectFieldsFromData(
  data: any,
  requestedFields?: string[],
  toolDefaultFields?: string[],
  toolSpecificRules?: Record<string, any>
): any {
  const effectiveFields = (requestedFields && requestedFields.length > 0) 
    ? requestedFields 
    : (toolDefaultFields && toolDefaultFields.length > 0 ? toolDefaultFields : []);
  
  const isDefaultMode = !(requestedFields && requestedFields.length > 0);

  if (effectiveFields.length === 0 || data === null || data === undefined) {
    return Array.isArray(data) ? [] : {};
  }

  if (Array.isArray(data)) {
    return data.map(item => _processSingleObjectInternal(item, effectiveFields, toolSpecificRules, isDefaultMode));
  } else {
    return _processSingleObjectInternal(data, effectiveFields, toolSpecificRules, isDefaultMode);
  }
}

const GET_PROJECTS_DEFAULT_FIELDS = [
  'id',
  'name',
  'description',
  'priorityLevel',
  'dueDate', // Date formatting to be handled in Subtask 2.2
  'status.name',
  'completedTime', // Date formatting to be handled in Subtask 2.2
  'taskCount'
];

const GET_PROJECTS_TOOL_SPECIFIC_RULES = {
  'dueDate': { postProcessField: (value: string | null | undefined) => formatDateToYYYYMMDD(value) },
  'completedTime': { postProcessField: (value: string | null | undefined) => value ? formatDateToYYYYMMDD(value) : null },
  'manager': { // As per PRD 2.1 for get_projects
    optionalContainerSimplification: (managerObj: any) => managerObj ? { 'manager.name': managerObj.name } : { 'manager.name': null }
  }
};

// PRD 2.2: Recommended Default Fields for get_projects_by_projectId
const GET_PROJECT_BY_ID_DEFAULT_FIELDS = [
  'id',
  'name',
  'description',
  'workspaceId',
  'priorityLevel',
  'dueDate',
  'startDate',
  'completedTime'
];

// PRD 2.2: Tool specific rules for get_projects_by_projectId
const GET_PROJECT_BY_ID_TOOL_SPECIFIC_RULES = {
  'dueDate': { postProcessField: (value: string | null | undefined) => formatDateToYYYYMMDD(value) },
  'startDate': { postProcessField: (value: string | null | undefined) => formatDateToYYYYMMDD(value) },
  'completedTime': { postProcessField: (value: string | null | undefined) => value ? formatDateToYYYYMMDD(value) : null },
  // PRD 2.2: Optional Field Simplification Default for manager
  'manager': { 
    optionalContainerSimplification: (managerObj: any) => managerObj && managerObj.name ? { 'manager.name': managerObj.name } : { 'manager.name': null }
  }
};

// PRD 2.3: Recommended Default Fields for get_tasks_by_taskId
const GET_TASK_BY_ID_DEFAULT_FIELDS = [
  'id',
  'name',
  'status.name', // Assuming status is an object with a name property
  'priority',
  'dueDate', 
  'scheduledStart',
  'scheduledEnd',
  'duration',
  'completed',
  'project.name' // Assuming project is an object with a name property
];

// PRD 2.3: Tool specific rules for get_tasks_by_taskId
const GET_TASK_BY_ID_TOOL_SPECIFIC_RULES = {
  'dueDate': { postProcessField: (value: string | null | undefined) => formatDateToYYYYMMDD(value) },
  // PRD 2.3: Optional Field Simplification Defaults
  'creator': {
    optionalContainerSimplification: (creatorObj: any) => creatorObj && creatorObj.name ? { 'creator.name': creatorObj.name } : { 'creator.name': null }
  },
  'workspace': {
    optionalContainerSimplification: (workspaceObj: any) => workspaceObj && workspaceObj.name ? { 'workspace.name': workspaceObj.name } : { 'workspace.name': null }
  },
  'project': {
    optionalContainerSimplification: (projectObj: any) => projectObj && projectObj.name ? { 'project.name': projectObj.name } : { 'project.name': null }
  }
  // Assignees array simplification will be added in Subtask 4.4
};

// PRD 2.4: Fixed fields for get_statuses
const GET_STATUSES_FIXED_FIELDS = [
  'name',
  'isDefaultStatus',
  'isResolvedStatus'
];

// PRD 2.5: Fixed fields for get_users_me
const GET_USERS_ME_FIXED_FIELDS = [
  'id',
  'name',
  'email'
];

// PRD 2.6: Fixed fields for get_users
const GET_USERS_FIXED_FIELDS = [
  'id',
  'name',
  'email'
];

// PRD 2.7: Default fields for get_workspaces
const GET_WORKSPACES_DEFAULT_FIELDS = [
  'id',
  'name'
];

// PRD 2.3 / Task 13.1: Default fields for get_tasks, aligning with get_tasks_by_taskId
const GET_TASKS_DEFAULT_FIELDS = [
  'id',
  'name',
  'status.name', 
  'priority',
  'dueDate', 
  'scheduledStart',
  'scheduledEnd',
  'duration',
  'completed',
  'project.name'
];

// Task 13.2: Tool specific rules for get_tasks
const GET_TASKS_TOOL_SPECIFIC_RULES = {
  // Date formatting rules for relevant fields present in a task object
  'dueDate': { postProcessField: (value: string | null | undefined) => formatDateToYYYYMMDD(value) },
  'completedTime': { postProcessField: (value: string | null | undefined) => value ? formatDateToYYYYMMDD(value) : null },
  'startOn': { postProcessField: (value: string | null | undefined) => formatDateToYYYYMMDD(value) },
  'scheduledStart': { postProcessField: (value: string | null | undefined) => formatDateToYYYYMMDD(value) },
  'scheduledEnd': { postProcessField: (value: string | null | undefined) => formatDateToYYYYMMDD(value) },
  'createdTime': { postProcessField: (value: string | null | undefined) => formatDateToYYYYMMDD(value) }, 
  'updatedTime': { postProcessField: (value: string | null | undefined) => formatDateToYYYYMMDD(value) }, 
  'lastInteractedTime': { postProcessField: (value: string | null | undefined) => formatDateToYYYYMMDD(value) },

  // Optional container simplification rules (as per PRD 1.3.1 and 2.3)
  'creator': {
    optionalContainerSimplification: (creatorObj: any) => creatorObj && creatorObj.name ? { 'creator.name': creatorObj.name } : { 'creator.name': null }
  },
  'workspace': {
    optionalContainerSimplification: (workspaceObj: any) => workspaceObj && workspaceObj.name ? { 'workspace.name': workspaceObj.name } : { 'workspace.name': null }
  },
  'project': {
    optionalContainerSimplification: (projectObj: any) => projectObj && projectObj.name ? { 'project.name': projectObj.name } : { 'project.name': null }
  },

  // Default/Optional item simplification for arrays (PRD 1.2.2, 2.3)
  'assignees': {
    defaultItemSimplification: (assignee: any) => assignee && assignee.name ? { name: assignee.name } : {}
  },
  'chunks': {
    defaultItemSimplification: (chunk: any) => {
      if (!chunk) return {};
      // Return all original properties of the chunk, but format dates within it
      return {
        ...chunk,
        scheduledStart: formatDateToYYYYMMDD(chunk.scheduledStart),
        scheduledEnd: formatDateToYYYYMMDD(chunk.scheduledEnd),
        completedTime: chunk.completedTime ? formatDateToYYYYMMDD(chunk.completedTime) : null
      };
    }
  }
  // `labels` is an array of strings, so no item simplification needed.
};

const server = new McpServer({
  name: 'Motion AI Assistant',
  version: '1.0.0'
});

function parameterizeEndpoint(endpoint: string, parameters: Record<string, any>): string {
  // Handle path parameters
  let path = endpoint.replace(/\{([^}]+)\}/g, (match, paramName) => {
    const value = parameters[paramName];
    if (value === undefined || value === null) {
      throw new Error(`Missing required parameter: ${paramName}`);
    }
    return encodeURIComponent(value);
  });

  // Handle query parameters
  const queryParams = Object.entries(parameters)
    .filter(([key]) => !endpoint.includes(`{${key}}`)) // Exclude path parameters
    .filter(([_, value]) => value !== undefined && value !== null) // Exclude null/undefined values
    .map(([key, value]) => {
      if (Array.isArray(value)) {
        return value.map(v => `${encodeURIComponent(key)}=${encodeURIComponent(v)}`).join('&');
      }
      return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
    })
    .join('&');

  if (queryParams) {
    path += `?${queryParams}`;
  }

  return path;
}

async function callApi(endpoint: string, method: string, body?: any, contentType?: string) {
  // Check rate limit only for calls to the Motion API (baseUrl)
  // Construct the full URL to check against baseUrl. 
  // The `endpoint` parameter to callApi is usually a path like '/projects', not a full URL.
  const fullUrl = endpoint.startsWith('http') ? endpoint : `${baseUrl}${endpoint}`;

  if (fullUrl.startsWith(baseUrl)) {
    const { allowed, waitTimeMs } = rateLimiter.checkAndRecordCall();
    if (!allowed && waitTimeMs !== undefined) { // Ensure waitTimeMs is defined before using it
      const waitTimeSec = Math.ceil(waitTimeMs / 1000);
      console.warn(`Motion API rate limit reached. Please wait ${waitTimeSec} seconds before trying again.`);
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              error: 'Rate Limit Exceeded',
              details: `Motion API rate limit reached. Please wait ${waitTimeSec} seconds before trying again.`,
              waitTimeSeconds: waitTimeSec
            })
          }
        ],
        isError: true
      };
    } else if (!allowed) {
        // Fallback if waitTimeMs is somehow undefined but call is not allowed
        console.warn(`Motion API rate limit reached. Please wait before trying again.`);
        return {
            content: [
                {
                    type: 'text',
                    text: JSON.stringify({
                        error: 'Rate Limit Exceeded',
                        details: `Motion API rate limit reached. Please wait a few minutes before trying again.`
                    })
                }
            ],
            isError: true
        };
    }
  }

  const headers: Record<string, string> = {};
  if (contentType) {
    headers['Content-Type'] = contentType;
  }
  // Retrieve API key from environment variable
  const apiKey = process.env.MOTION_API_KEY;
  if (!apiKey) {
    // Return an error response if the API key is missing
    // This prevents leaking information about the missing key in thrown errors
    console.error("Error: MOTION_API_KEY environment variable not set.");
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({ error: 'Configuration error', details: 'MOTION_API_KEY environment variable not set. Please configure it in your MCP client.' })
        }
      ],
      isError: true // Indicate that this is a tool execution error
    };
  }
  headers['X-API-Key'] = apiKey; // Add the API key header

  const response = await fetch(`${baseUrl}${endpoint}`, {
    method,
    headers,
    body: body ? JSON.stringify(body) : undefined
  });
  
  // Check for non-OK responses after fetch, but before trying to parse JSON
  if (!response.ok) {
    // Attempt to read error details, but handle cases where it might not be JSON
    let errorDetails = `HTTP error! status: ${response.status}`;
    try {
        const errorData = await response.json();
        errorDetails = JSON.stringify(errorData);
    } catch (e) {
        // If response is not JSON, use the status text or default message
        errorDetails = response.statusText || errorDetails;
    }
    console.error("API call failed:", errorDetails);
    return {
        content: [
            {
                type: 'text',
                text: JSON.stringify({ error: 'API Error', details: errorDetails })
            }
        ],
        isError: true // Indicate a tool execution error
    };
  }

  // Proceed to parse JSON only if the response was ok
  const data = await response.json();
  return {
    content: [
      {
        type: 'text',
        text: JSON.stringify(data)
      }
    ]
    // No isError field means success
  };
}

function registerTool(name: string, description: string, parameters: any, handler: (params: any) => Promise<any>) {
  try {
    // Directly use the parameters as passed.
    // The MCP SDK is expected to handle plain objects with Zod types,
    // or z.object() instances if tools are defined that way.
    console.error(`[MCP Server main.ts] Registering tool: ${name} with parameters:`, JSON.stringify(parameters, null, 2));
    server.tool(name, description, parameters, handler);
  } catch (error) {
    console.error(`Failed to register tool ${name}:`, error);
  }
}

/******************************************************************************
 * TODO AUTOGENERATED SECTION STARTS                                          *
 * TODO PLEASE CHECK WORKSPACEID DESCRIPTIONS AND OTHER FIELDS IN TOOL PARAMS *
 ******************************************************************************/

// Default tools
registerTool(
  'get_servers',
  `Get available servers from the Swagger spec`,
  {},
  async () => {
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify([{"url":"https://api.usemotion.com/v1"}])
        }
      ]
    };
  }
);

registerTool(
  'set_base_url',
  `Set the base URL for API requests`,
  { // MODIFIED: Was z.object()
    url: z.string().describe('The new base URL')
  },
  async (params) => {
    const validatedParams = z.object({ url: z.string() }).parse(params);
    baseUrl = validatedParams.url;
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({ success: true, newBaseUrl: baseUrl })
        }
      ]
    };
  }
);

/* ## Comment Content Input

When posting a comment, the content will be treated as [GitHub Flavored Markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax).
 */
registerTool(
  'post_comments',
  `**Comment Content Input:**

When posting a comment, the content will be treated as [GitHub Flavored Markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax).
`,
  { // MODIFIED: Was z.object()
    body: z.object({
      taskId: z.string().describe('The ID of the task on which to place the comment.'),
      content: z.string().describe('The content of the comment, in GitHub Flavored Markdown.')
    })
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    body: z.object({
      taskId: z.string().describe('The ID of the task on which to place the comment.'),
      content: z.string().describe('The content of the comment, in GitHub Flavored Markdown.')
    })
  }).parse(params);
      const endpoint = parameterizeEndpoint('/comments', validatedParams);
      return callApi(endpoint, 'POST', validatedParams, 'application/json');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* List Comments */
registerTool(
  'get_comments',
  `**Overview:** Lists all comments for a specific task. Returns a paginated list of comment objects, each including its \`content\` (HTML), \`creation timestamp\`, and \`creator information\` (ID, name, email). Supports pagination via a \`cursor\`.`,
  { // MODIFIED: Was z.object()
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    taskId: z.string().describe('The ID of the task from which to retrieve comments.')
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    taskId: z.string().describe('The ID of the task from which to retrieve comments.')
  }).parse(params);
      const endpoint = parameterizeEndpoint('/comments', validatedParams);
      return callApi(endpoint, 'GET');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* Retrieve Project */
registerTool(
  'get_projects_by_projectId',
  `**Overview:** Retrieves detailed information for a single project, specified by its ID.
Use the \`fields\` parameter to select the exact information you need.

**Available Response Fields:**

1.  **Simple Fields** (directly accessible):
    *   \`id\`, \`name\`, \`description\`, \`workspaceId\`, \`priorityLevel\`
    *   \`dueDate\` (Note:YYYY-MM-DD format)
    *   \`startDate\` (Note:YYYY-MM-DD format)
    *   \`completedTime\` (Note:YYYY-MM-DD format, or null if not completed)

2.  **Nested Object Fields** (use dot notation):
    *   \`manager.name\` (Note: To get the manager\\'s name, include "manager" in your \`fields\` request, e.g., \`fields: ["manager"]\`. The response will then contain \`manager.name\` with the name, or null if no manager is assigned.)

**Examples:**
- For core project details: \`fields: ["id", "name", "description", "dueDate"]\`
- To include the manager\\'s name: \`fields: ["id", "name", "manager"]\`

**Default Fields:** (when \`fields\` is omitted):
${GET_PROJECT_BY_ID_DEFAULT_FIELDS.join(', ')}`,
  { // MODIFIED: Was z.object()
    projectId: z.string().describe('The ID of the project to retrieve.'),
    fields: z.array(z.string()).optional().describe('Optional. Specify which fields to include in the response. Uses defaults if not provided.')
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        projectId: z.string().describe('The ID of the project to retrieve.'),
        fields: z.array(z.string()).optional()
      }).parse(params);
      
      const endpoint = parameterizeEndpoint('/projects/{projectId}', { projectId: validatedParams.projectId });
      const apiResponseWrapper = await callApi(endpoint, 'GET');

      // Handle potential API error from callApi
      if (apiResponseWrapper.isError) {
        return apiResponseWrapper; // Return the error response directly
      }

      let rawProjectData;
      try {
        rawProjectData = JSON.parse(apiResponseWrapper.content[0].text);
      } catch (e) {
        console.error(`Failed to parse project data for projectId ${validatedParams.projectId}:`, e);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'API Response Error', details: 'Failed to parse project data' })
            }
          ],
          isError: true
        };
      }

      // TODO (Subtask 3.1 cont.): Integrate selectFieldsFromData here using GET_PROJECT_BY_ID_DEFAULT_FIELDS
      // and later GET_PROJECT_BY_ID_TOOL_SPECIFIC_RULES (Subtask 3.2 & 3.3)
      const processedData = selectFieldsFromData(
        rawProjectData, 
        validatedParams.fields, 
        GET_PROJECT_BY_ID_DEFAULT_FIELDS,
        GET_PROJECT_BY_ID_TOOL_SPECIFIC_RULES
      );

      return { 
        content: [
          {
            type: 'text',
            text: JSON.stringify(processedData)
          }
        ]
      };

    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* List Projects */
registerTool(
  'get_projects',
  `**Overview:** Lists projects for a specified workspace.
You can customize the information returned for each project using the \`fields\` parameter.
Supports pagination using the \`cursor\` parameter.

**Available Response Fields:**

1.  **Simple Fields** (directly accessible):
    *   \`id\`, \`name\`, \`description\`, \`priorityLevel\`
    *   \`dueDate\` (Note:YYYY-MM-DD format)
    *   \`completedTime\` (Note:YYYY-MM-DD format, or null if not completed)
    *   \`taskCount\`
    *   \`workspaceId\`

2.  **Nested Object Fields** (use dot notation):
    *   \`status.name\` (e.g., "In Progress" - this is the project\\'s overall status)
    *   \`manager.name\` (Note: To get the manager\\'s name, include "manager" in your \`fields\` request, e.g., \`fields: ["manager"]\`. The response will then contain \`manager.name\` with the name, or null if no manager is assigned.)

3.  **Meta Object** (for pagination):
    *   \`meta.cursor\` (Note: If more projects are available, this field will contain a cursor string. Pass this string to the \`cursor\` parameter in your next call to fetch the subsequent set of projects.)

**Examples:**
- For a basic list view: \`fields: ["id", "name", "status.name"]\`
- To include manager\\'s name and due date: \`fields: ["id", "name", "dueDate", "manager"]\`
- For description and task count: \`fields: ["id", "name", "description", "taskCount"]\`

**Default Fields:** (when \`fields\` is omitted):
${GET_PROJECTS_DEFAULT_FIELDS.join(', ')}`,
  { // MODIFIED: Was z.object()
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    workspaceId: z.string().describe('The ID of the workspace to list projects from.'),
    fields: z.array(z.string()).optional().describe('Optional. Specify which fields to include in the response. Uses defaults if not provided.')
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
        workspaceId: z.string().describe('The ID of the workspace to list projects from.'),
        fields: z.array(z.string()).optional()
      }).parse(params);
      
      const { fields, ...apiParams } = validatedParams;
      
      const endpoint = parameterizeEndpoint('/projects', apiParams);
      const apiResponseWrapper = await callApi(endpoint, 'GET');

      if (apiResponseWrapper.isError) {
        return apiResponseWrapper;
      }

      let rawProjectsData;
      try {
        rawProjectsData = JSON.parse(apiResponseWrapper.content[0].text);
      } catch (e) {
        console.error("Failed to parse projects API response:", e);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'API Response Error', details: 'Failed to parse projects data' })
            }
          ],
          isError: true
        };
      }

      const projectsArray = rawProjectsData?.projects;

      if (!Array.isArray(projectsArray)) {
         console.error("API response for /projects did not contain a projects array.", rawProjectsData);
         return {
           content: [
             {
               type: 'text',
               text: JSON.stringify({ error: 'API Response Error', details: 'Projects data is not in expected format' })
             }
           ],
           isError: true
         };
      }

      const processedData = selectFieldsFromData(projectsArray, fields, GET_PROJECTS_DEFAULT_FIELDS, GET_PROJECTS_TOOL_SPECIFIC_RULES); 

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({ projects: processedData, meta: rawProjectsData.meta || {} })
          }
        ]
      };

    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* Create Project */
registerTool(
  'post_projects',
  `**Overview:** Creates a new project in Motion. Ensure you provide the required \`name\` and \`workspaceId\`. Optional fields include \`dueDate\`, \`description\`, \`labels\`, and \`priority\`. Refer to Motion API documentation for details on \`projectDefinitionId\` and template-based project creation if needed, as those are not fully detailed here to keep this concise.

**Request Parameters:**
**Required Body Parameters:**
- \`name\` (string): The name of the project.
- \`workspaceId\` (string): The workspace ID for the project.

**Optional Body Parameters:**
- \`dueDate\` (string, ISO 8601 date, e.g., "2024-03-12T10:52:55.714-06:00"): Project due date.
- \`description\` (string): Project description. HTML input is accepted.
- \`labels\` (array of string): List of label names for the project.
- \`priority\` (string): Options: "ASAP", "HIGH", "MEDIUM" (default), "LOW".

**Response Format:**
Response on success: \`{ status: "SUCCESS", id: "<NEW_PROJECT_ID>" }\`.
Response on failure: \`{ status: "FAILURE", id: null }\`.`,
  {
    body: z.object({
      dueDate: z.string().optional().describe("Optional. Project due date (e.g., \"2024-03-12T10:52:55.714-06:00\")."),
      name: z.string().describe("Required. The name of the project."),
      workspaceId: z.string().describe("Required. The workspace to which the project belongs."),
      description: z.string().optional().describe("Optional. Project description. HTML input is accepted."),
      labels: z.array(z.string()).optional().describe('Optional. List of label names for the project. Existing options: ASAP, HIGH, MEDIUM, LOW - but this seems to be for priority. For labels, it is just an array of strings.'), // Adjusted based on API doc
      priority: z.string().optional().describe('Optional. Priority of the project. Options: "ASAP", "HIGH", "MEDIUM" (default), "LOW".') 
    })
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        body: z.object({
          dueDate: z.string().optional(),
          name: z.string(),
          workspaceId: z.string(),
          description: z.string().optional(),
          labels: z.array(z.string()).optional(), 
          priority: z.string().optional() 
        })
      }).parse(params);
      
      const endpoint = parameterizeEndpoint('/projects', {});
      const apiResponseWrapper = await callApi(endpoint, 'POST', validatedParams.body, 'application/json');

      if (apiResponseWrapper.isError) {
        // callApi already includes error details, but PRD wants specific format for post_tasks failure
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ status: 'FAILURE', id: null })
            }
          ]
        };
      }

      // Assuming successful API call returns the created task object with an id
      let createdTaskData;
      try {
        createdTaskData = JSON.parse(apiResponseWrapper.content[0].text);
        if (createdTaskData && createdTaskData.id) {
          return {
            content: [
              {
                type: 'text',
                text: JSON.stringify({ status: 'SUCCESS', id: createdTaskData.id })
              }
            ]
          };
        } else {
          // If API success but no ID or unexpected format
          console.error('post_tasks: API success but ID missing in response', createdTaskData);
          return {
            content: [
              {
                type: 'text',
                text: JSON.stringify({ status: 'FAILURE', id: null })
              }
            ]
          };
        }
      } catch (e) {
        console.error('post_tasks: Failed to parse successful API response', e);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ status: 'FAILURE', id: null })
            }
          ]
        };
      }

    } catch (error) {
      // Handles Zod validation errors and any other unexpected errors before/after API call
      console.error('Error in post_tasks handler:', error);
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({ status: 'FAILURE', id: null })
          }
        ]
      };
    }
  }
);

/* ## Description Input */
registerTool(
  'post_recurring-tasks',
  `**Description Input:**

When passing in a task description, the input will be treated as [GitHub Flavored Markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax)

# Defining Frequencies

## Defining specific days for a frequency

### Note

Defining days should always be used along with a specific frequency type as defined below.
A array of days should never be used on its own. See examples below.

When picking a set of specific week days, we expect it to be defined as an array with a subset of the following values.

- MO - Monday
- TU - Tuesday
- WE - Wednesday
- TH - Thursday
- FR - Friday
- SA - Saturday
- SU - Sunday

Example - \`[MO, FR, SU]\` would mean Monday, Friday and Sunday.

## Defining a daily frequency

- \`daily_every_day\`
- \`daily_every_week_day\`
- \`daily_specific_days_\$DAYS_ARRAY\$\`
- Ex: \`daily_specific_days_\[MO, TU, FR\]\`

## Defining a weekly frequency

- \`weekly_any_day\`
- \`weekly_any_week_day\`
- \`weekly_specific_days_\$DAYS_ARRAY\$\`
- Ex: \`weekly_specific_days_[MO, TU, FR]\`

## Defining a bi-weekly frequency

- \`biweekly_first_week_specific_days_\$DAYS_ARRAY\$\`
- Ex: \`biweekly_first_week_specific_days_[MO, TU, FR]\`
- \`biweekly_first_week_any_day\`
- \`biweekly_first_week_any_week_day\`
- \`biweekly_second_week_any_day\`
- \`biweekly_second_week_any_week_day\`

## Defining a monthly frequency

### Specific Week Day Options

When choosing the 1st, 2nd, 3rd, 4th or last day of the week for the month, it takes the form of any of the following where $DAY$ can be substituted for the day code mentioned above.

- \`monthly_first_\$DAY\$\`
- \`monthly_second_\$DAY\$\`
- \`monthly_third_\$DAY\$\`
- \`monthly_fourth_\$DAY\$\`
- \`monthly_last_\$DAY\$\`

**Example**
\`monthly_first_MO\`

### Specific Day Options

When choosing a specific day of the month, for example the 6th, it would be defined with just the number like below.

Examples:

- \`monthly_1\`
- \`monthly_15\`
- \`monthly_31\`

In the case you choose a numeric value for a month that does not have that many days, we will default to the last day of the month.

### Specific Week Options

**Any Day**

- \`monthly_any_day_first_week\`
- \`monthly_any_day_second_week\`
- \`monthly_any_day_third_week\`
- \`monthly_any_day_fourth_week\`
- \`monthly_any_day_last_week\`

**Any Week Day**

- \`monthly_any_week_day_first_week\`
- \`monthly_any_week_day_second_week\`
- \`monthly_any_week_day_third_week\`
- \`monthly_any_week_day_fourth_week\`
- \`monthly_any_week_day_last_week\`

### Other Options

- \`monthly_last_day_of_month\`
- \`monthly_any_week_day_of_month\`
- \`monthly_any_day_of_month\`

## Defining a quarterly frequency

### First Days

- \`quarterly_first_day\`
- \`quarterly_first_week_day\`
- \`quarterly_first_\$DAY\$\`
- Ex. \`quarterly_first_MO\`

### Last Days

- \`quarterly_last_day\`
- \`quarterly_last_week_day\`
- \`quarterly_last_\$DAY\$\`
- Ex. \`quarterly_last_MO\`

### Other Options

- \`quarterly_any_day_first_week\`
- \`quarterly_any_day_second_week\`
- \`quarterly_any_day_last_week\`
- \`quarterly_any_day_first_month\`
- \`quarterly_any_day_second_month\`
- \`quarterly_any_day_third_month\``,
  { // MODIFIED: Was z.object()
    body: z.object({
      frequency: z.string().describe("The recurrence rule for the task. Refer to the main tool description for detailed format examples like 'daily_every_day' or 'weekly_specific_days_[MO,WE,FR]'."),
      deadlineType: z.string().optional().describe("Optional. The type of deadline for the recurring task (e.g., 'SOFT', 'HARD')."),
      duration: z.string().optional().describe("Optional. The duration of each instance of the recurring task. Send numbers as strings (e.g., \"30\" for 30 minutes), or use specific keywords like \"NONE\" or \"REMINDER\".") ,
      startingOn: z.string().optional().describe("Optional. The date when the recurring task should first start, in YYYY-MM-DD format."),
      idealTime: z.string().optional().describe("Optional. The ideal time of day for the task to be scheduled, if applicable (e.g., '09:00')."),
      schedule: z.string().optional().describe("Optional. The name or ID of a specific schedule to use for these recurring tasks."),
      name: z.string().describe("The name or title for the recurring task."),
      workspaceId: z.string().describe("The ID of the workspace where the recurring task will be created."),
      description: z.string().optional().describe("Optional. A description for the recurring task, in GitHub Flavored Markdown."),
      priority: z.string().describe("The priority for the recurring task (e.g., 'ASAP', 'HIGH', 'MEDIUM', 'LOW')."),
      assigneeId: z.string().describe("The ID of the user to whom the recurring tasks will be assigned.")
    })
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        body: z.object({
          frequency: z.string().describe("The recurrence rule for the task. Refer to the main tool description for detailed format examples like 'daily_every_day' or 'weekly_specific_days_[MO,WE,FR]'."),
          deadlineType: z.string().optional().describe("Optional. The type of deadline for the recurring task (e.g., 'SOFT', 'HARD')."),
          duration: z.string().optional().describe("Optional. The duration of each instance of the recurring task. Send numbers as strings (e.g., \"30\" for 30 minutes), or use specific keywords like \"NONE\" or \"REMINDER\".") ,
          startingOn: z.string().optional().describe("Optional. The date when the recurring task should first start, in YYYY-MM-DD format."),
          idealTime: z.string().optional().describe("Optional. The ideal time of day for the task to be scheduled, if applicable (e.g., '09:00')."),
          schedule: z.string().optional().describe("Optional. The name or ID of a specific schedule to use for these recurring tasks."),
          name: z.string().describe("The name or title for the recurring task."),
          workspaceId: z.string().describe("The ID of the workspace where the recurring task will be created."),
          description: z.string().optional().describe("Optional. A description for the recurring task, in GitHub Flavored Markdown."),
          priority: z.string().describe("The priority for the recurring task (e.g., 'ASAP', 'HIGH', 'MEDIUM', 'LOW')."),
          assigneeId: z.string().describe("The ID of the user to whom the recurring tasks will be assigned.")
        })
      }).parse(params);
      
      const { body } = validatedParams;

      // Handle duration parsing
      let apiDuration: string | number | undefined = body.duration;
      if (typeof body.duration === 'string') {
        const numericDuration = parseInt(body.duration, 10);
        if (!isNaN(numericDuration) && numericDuration.toString() === body.duration) {
          apiDuration = numericDuration;
        } else {
          // It's a non-numeric string like "NONE" or "REMINDER", keep as is
          apiDuration = body.duration;
        }
      }

      const apiBody = {
        ...body,
        duration: apiDuration
      };
      
      const endpoint = parameterizeEndpoint('/recurring-tasks', {});
      
      return callApi(endpoint, 'POST', apiBody, 'application/json');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* List Recurring Tasks */
registerTool(
  'get_recurring-tasks',
  `**Overview:** Lists all recurring task configurations for a specified workspace. Returns a paginated list. Each recurring task object can include details like its \`name\`, \`creator\`, \`assignee\`, associated \`project\`, \`status\`, \`priority\`, \`labels\`, and full \`workspace information\`. Use the \`cursor\` for pagination if many recurring tasks exist.`,
  { // MODIFIED: Was z.object()
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    workspaceId: z.string().describe('The id of the workspace you want tasks from.')
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    workspaceId: z.string().describe('The id of the workspace you want tasks from.')
  }).parse(params);
      const endpoint = parameterizeEndpoint('/recurring-tasks', validatedParams);
      return callApi(endpoint, 'GET');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* Delete a Recurring Task */
registerTool(
  'delete_recurring-tasks_by_taskId',
  `Permanently deletes a recurring task configuration based on its \`ID\`.`,
  { // MODIFIED: Was z.object()
    taskId: z.string().describe('The ID of the recurring task configuration to delete.')
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    taskId: z.string().describe('The ID of the recurring task configuration to delete.')
  }).parse(params);
      const endpoint = parameterizeEndpoint('/recurring-tasks/{taskId}', validatedParams);
      return callApi(endpoint, 'DELETE');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* Get a list of schedules for your user */
registerTool(
  'get_schedules',
  `Get a list of schedules for your user`,
  {},
  async (params) => {
    try {
      const validatedParams = z.object({}).parse(params);
      const endpoint = parameterizeEndpoint('/schedules', validatedParams);
      return callApi(endpoint, 'GET');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* List statuses for a workspace */
registerTool(
  'get_statuses',
  `**Overview:** Lists all available task statuses for a given workspace.
**Fixed Fields:** This tool always returns an array of status objects, and each object contains the following fixed fields:
- \`name\`: The name of the status (e.g., "Todo", "In Progress").
- \`isDefaultStatus\`: A boolean indicating if this is the default status for new tasks in the workspace.
- \`isResolvedStatus\`: A boolean indicating if tasks with this status are considered resolved/completed.
**Notes:** This tool does *not* support the \`fields\` parameter.`,
  { // MODIFIED: Was z.object()
    workspaceId: z.string().describe('The ID of the workspace for which to retrieve statuses.')
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        workspaceId: z.string()
      }).parse(params);
      
      const endpoint = parameterizeEndpoint('/statuses', { workspaceId: validatedParams.workspaceId });
      const apiResponseWrapper = await callApi(endpoint, 'GET');

      if (apiResponseWrapper.isError) {
        return apiResponseWrapper;
      }

      let rawStatusesData;
      try {
        const parsedResponse = JSON.parse(apiResponseWrapper.content[0].text);
        if (Array.isArray(parsedResponse)) {
          rawStatusesData = parsedResponse;
        } else if (parsedResponse && Array.isArray(parsedResponse.statuses)) {
          rawStatusesData = parsedResponse.statuses;
        } else {
          throw new Error('Response format not recognized or statuses array missing');
        }
      } catch (e: any) {
        console.error(`Failed to parse statuses data for workspace ${validatedParams.workspaceId}:`, e.message);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'API Response Error', details: `Failed to parse statuses data: ${e.message}` })
            }
          ],
          isError: true
        };
      }

      const processedData = selectFieldsFromData(
        rawStatusesData,
        GET_STATUSES_FIXED_FIELDS, 
        GET_STATUSES_FIXED_FIELDS  
      );

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(processedData) 
          }
        ]
      };

    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* Update a Task */
registerTool(
  'patch_tasks_by_taskId',
  `**Overview:** Updates an existing task identified by its unique ID. You can modify various attributes of the task such as its name, due date, assignee, status, and more. This tool supports partial updates, meaning only the fields you provide in the request body will be changed.

**Request Parameters:**

*   \`taskId\` (string, required): The unique identifier of the task you want to update.
*   \`fields\` (array of strings, optional): Specify which fields of the updated task object should be included in the response. If omitted, a default set of fields (identical to those returned by the \`get_tasks_by_taskId\` tool) will be provided.
*   \`body\` (object, required): An object containing the task attributes you wish to update. Provide only the fields you want to change:
    *   \`name\` (string, optional): The new name or title for the task.
    *   \`dueDate\` (string, optional): The task's new due date. Accepts YYYY-MM-DD format or a full ISO 8601 timestamp. This can be crucial for auto-scheduling.
    *   \`assigneeId\` (string or null, optional): The ID of the user to assign the task to. To unassign the task, provide \`null\`.
    *   \`duration\` (string, optional): The task's duration. Provide an integer as a string (e.g., "30" for 30 minutes), or a specific string values, either "NONE" or "REMINDER".
    *   \`status\` (string, optional): The new status name for the task (e.g., "In Progress", "Completed"). Ensure the status exists in the workspace.
    *   \`autoScheduled\` (object or null, optional): An object to configure auto-scheduling for the task, or \`null\` to disable auto-scheduling.
        *   If an object is provided, it can contain:
            *   \`startDate\` (string, optional): The date when auto-scheduling should begin (YYYY-MM-DD or ISO 8601).
            *   \`deadlineType\` (string, optional): The type of deadline for auto-scheduling (e.g., "SOFT", "HARD").
            *   \`schedule\` (string, optional): The name or ID of a specific schedule to use.
        *   Note: The task's target status must have auto-scheduling enabled in Motion for these settings to take effect.
    *   \`projectId\` (string, optional): The ID of the project to associate this task with.
    *   \`description\` (string, optional): The updated task description, which can include GitHub Flavored Markdown.
    *   \`priority\` (string, optional): The task's priority level. Valid values are "ASAP", "HIGH", "MEDIUM", "LOW".
    *   \`labels\` (array of strings, optional): An array of label names to set on the task. This will replace any existing labels on the task.

**Response Structure:**

Upon successful execution, this tool returns the **complete updated task object**. The specific fields included in this object depend on the optional \`fields\` parameter you provide in the request:
*   If you use the \`fields\` parameter, only the fields you specify will be returned.
*   If the \`fields\` parameter is omitted or empty, a default set of task fields will be returned.

**Notes:** The "Available Response Fields" for the updated task object, their data types, and how to access nested information (e.g., \`status.name\`, \`project.name\`, simplified \`creator.name\`, or array contents like \`assignees\`) are identical to those provided by the \`get_tasks_by_taskId\` tool. Please refer to the documentation for \`get_tasks_by_taskId\` for a comprehensive list and detailed explanations of all possible response fields.

The response is the updated task object, formatted based on the \`fields\` parameter or defaults (similar to get_tasks_by_taskId).`,
  {
    taskId: z.string().describe('The unique identifier of the task to retrieve.'),
    fields: z.array(z.string()).optional().describe('Optional. Specify which fields to include in the response. Uses defaults if not provided.'),
    body: z.object({
      name: z.string().optional().describe("The new title of the task."),
      dueDate: z.string().optional().describe("ISO 8601 string for the task\'s due date. Can be required for certain auto-scheduling configurations."),
      assigneeId: z.string().nullable().optional().describe("The ID of the user to assign the task to. Set to null to unassign."),
      duration: z.string().optional().describe("Task duration: an integer sent as a string (e.g., \"30\"), or a specific strings, either \"NONE\" or \"REMINDER\"."),
      status: z.string().optional().describe("The new status for the task. If not provided, defaults to the workspace default or remains unchanged."),
      autoScheduled: z.object({
        startDate: z.string().optional().describe("The date when auto-scheduling should begin (ISO 8601 string)."),
        deadlineType: z.string().optional().describe("The type of deadline for auto-scheduling (e.g., \"SOFT\", \"HARD\")."),
        schedule: z.string().optional().describe("The name or ID of the specific schedule to use for auto-scheduling.")
      }).nullable().optional().describe("Object to configure auto-scheduling, or null to disable. Task\'s status must have auto-scheduling enabled."),
      projectId: z.string().optional().describe("The ID of the project to associate the task with."),
      description: z.string().optional().describe("The task\'s description, in GitHub Flavored Markdown."),
      priority: z.string().optional().describe("Set the task\'s priority. Valid values: \"ASAP\", \"HIGH\", \"MEDIUM\", \"LOW\"."),
      labels: z.array(z.string()).optional().describe("An array of label names to set on the task. This will typically replace existing labels.")
    })
  },
  async (params) => {
    const originalTaskId = params.taskId; // Store for error reporting
    try {
      const validatedParams = z.object({
        taskId: z.string().describe('The unique identifier of the task to retrieve.'),
        fields: z.array(z.string()).optional(), // Validate fields parameter
        body: z.object({
          name: z.string().optional().describe("The new title of the task."),
          dueDate: z.string().optional().describe("ISO 8601 string for the task\'s due date. Can be required for certain auto-scheduling configurations."),
          assigneeId: z.string().nullable().optional().describe("The ID of the user to assign the task to. Set to null to unassign."),
          duration: z.string().optional().describe("Task duration: an integer sent as a string (e.g., \"30\"), or a specific strings, either \"NONE\" or \"REMINDER\"."),
          status: z.string().optional().describe("The new status for the task. If not provided, defaults to the workspace default or remains unchanged."),
          autoScheduled: z.object({
            startDate: z.string().optional().describe("The date when auto-scheduling should begin (ISO 8601 string)."),
            deadlineType: z.string().optional().describe("The type of deadline for auto-scheduling (e.g., \"SOFT\", \"HARD\")."),
            schedule: z.string().optional().describe("The name or ID of the specific schedule to use for auto-scheduling.")
          }).nullable().optional().describe("Object to configure auto-scheduling, or null to disable. Task\'s status must have auto-scheduling enabled."),
          projectId: z.string().optional().describe("The ID of the project to associate the task with."),
          description: z.string().optional().describe("The task\'s description, in GitHub Flavored Markdown."),
          priority: z.string().optional().describe("Set the task\'s priority. Valid values: \"ASAP\", \"HIGH\", \"MEDIUM\", \"LOW\"."),
          labels: z.array(z.string()).optional().describe("An array of label names to set on the task. This will typically replace existing labels.")
        })
      }).parse(params);
      
      const { taskId, body, fields } = validatedParams;
      
      // Process duration from string to number if applicable
      let apiDuration: string | number | undefined = body.duration;
      if (typeof body.duration === 'string') {
        const numericDuration = parseInt(body.duration, 10);
        if (!isNaN(numericDuration) && numericDuration.toString() === body.duration) {
          apiDuration = numericDuration;
        } else {
          // It's a non-numeric string like "NONE" or "REMINDER", keep as is
          apiDuration = body.duration;
        }
      }

      const apiBody = {
        ...body,
        duration: apiDuration
      };
      
      const endpoint = parameterizeEndpoint('/tasks/{taskId}', { taskId });
      const apiResponseWrapper = await callApi(endpoint, 'PATCH', apiBody, 'application/json');

      if (apiResponseWrapper.isError) {
        // API call failed (e.g., network error, Motion API error like 4xx/5xx)
        // callApi already wraps the error from Motion, so we use that if available
        // Otherwise, construct the specific failure response
        let errorDetails = 'API call failed during PATCH.';
        if (apiResponseWrapper.content && apiResponseWrapper.content[0] && apiResponseWrapper.content[0].text) {
            try {
                const parsedError = JSON.parse(apiResponseWrapper.content[0].text);
                errorDetails = parsedError.details || parsedError.error || errorDetails;
            } catch (e) {
                // Keep default errorDetails if parsing fails
            }
        }
        console.error(`patch_tasks_by_taskId: API call failed for taskId ${taskId}. Details: ${errorDetails}`);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ status: 'FAILURE', id: taskId })
            }
          ]
        };
      }
      
      // Assuming PATCH returns the full updated task object, as per required_tools.md example for Tool 11
      let updatedTaskData;
      try {
        updatedTaskData = JSON.parse(apiResponseWrapper.content[0].text);
      } catch (e) {
        console.error(`patch_tasks_by_taskId: Failed to parse successful PATCH response for taskId ${taskId}:`, e);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ status: 'FAILURE', id: taskId })
            }
          ]
        };
      }

      // Process the updated task data using selectFieldsFromData
      // This aligns with get_tasks_by_taskId behavior as per PRD 2.9
      const processedData = selectFieldsFromData(
        updatedTaskData,
        fields, // User-specified fields or undefined for default
        GET_TASK_BY_ID_DEFAULT_FIELDS,
        GET_TASK_BY_ID_TOOL_SPECIFIC_RULES
      );

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(processedData) // Return the processed task data
          }
        ]
      };

    } catch (error) {
      // Catches Zod validation errors or other unexpected errors
      console.error(`Error in patch_tasks_by_taskId handler for taskId ${originalTaskId}:`, error);
      return {
        content: [
          {
            type: 'text',
            // Ensure originalTaskId is used here if validatedParams.taskId is not available due to validation failure
            text: JSON.stringify({ status: 'FAILURE', id: originalTaskId }) 
          }
        ]
      };
    }
  }
);

/* Retrieve a Task */
registerTool(
  'get_tasks_by_taskId',
  `**Overview:** Retrieves detailed information for a single task, specified by its ID.
Use the \`fields\` parameter to select the exact information you need.

**Available Response Fields:**

1.  **Simple Fields** (directly accessible):
    *   \`id\`, \`name\`, \`description\`, \`duration\`, \`dueDate\` (YYYY-MM-DD format),
    *   \`deadlineType\`, \`completed\` (boolean), \`completedTime\` (YYYY-MM-DD format, or null if not completed),
    *   \`updatedTime\`, \`startOn\` (YYYY-MM-DD format), \`priority\`, \`scheduledStart\` (timestamp or null),
    *   \`scheduledEnd\` (timestamp or null), \`schedulingIssue\` (boolean),
    *   \`createdTime\`, \`lastInteractedTime\`.

2.  **Nested Object Fields** (use dot notation for direct access to sub-fields):
    *   \`creator.id\`, \`creator.name\`, \`creator.email\`
    *   \`workspace.id\`, \`workspace.name\`, \`workspace.type\`
    *   \`project.id\`, \`project.name\`, \`project.description\` (Note: if the task is associated with a project)
    *   \`status.name\`, \`status.isDefaultStatus\`, \`status.isResolvedStatus\`
    *   **Note on simplified access for certain objects:** If you request \`creator\`, \`workspace\`, or \`project\` directly in the \`fields\` parameter (e.g., \`fields: ["creator"]\`), you will receive a simplified object containing just the name (e.g., \`{"creator.name": "Actual Creator Name"}\`). To get all specific sub-fields listed above, request them explicitly using dot notation (e.g., \`fields: ["creator.id", "creator.name"]\`).

3.  **Array Fields:**
    *   \`assignees\` (Note: Requesting \`assignees\` via \`fields: ["assignees"]\` returns an array of objects, each simplified to contain just the assignee's name: \`[{ name: 'Assignee Name1' }, ...]\`. For full assignee details, use the \`get_users\` tool with their IDs if needed.)
    *   \`labels\` (Note: Returns an array of label strings associated with the task, e.g., \`["urgent", "bug"]\`.)
    *   \`chunks\` (Note: Returns an array of task chunks (scheduled time blocks). Each chunk object includes fields like \`id\`, \`duration\`, \`scheduledStart\` (timestamp), \`scheduledEnd\` (timestamp), \`completedTime\` (timestamp or null), \`isFixed\` (boolean). Dates within chunks are also formatted to YYYY-MM-DD where applicable by the underlying processing logic.)

**Examples:**
- For basic task information: \`fields: ["id", "name", "status.name", "dueDate"]\`
- For scheduling details including chunks: \`fields: ["id", "name", "scheduledStart", "scheduledEnd", "duration", "chunks"]\`
- To include creator name and assignee names: \`fields: ["id", "name", "creator", "assignees"]\`
- To get specific project details: \`fields: ["id", "name", "project.id", "project.name"]\`

**Default Fields:** (when \`fields\` is omitted):
${GET_TASK_BY_ID_DEFAULT_FIELDS.join(', ')}`,
  { // Plain object, NOT z.object()
    taskId: z.string().describe('The unique identifier of the task to retrieve.'),
    fields: z.array(z.string()).optional().describe('Optional. Specify which fields to include in the response. Uses defaults if not provided. See tool description for available fields and examples.')
  },
  async (params: any) => {
    console.error(`[MCP Server get_tasks_by_taskId] Received params raw:`, JSON.stringify(params, null, 2));
    try {
      // REINSTATE Zod parsing of the params object for robustness
      const validatedParams = z.object({
        taskId: z.string().describe('The unique identifier of the task to retrieve.'), // Ensure this exact schema matches registration
        fields: z.array(z.string()).optional().describe('Optional. Specify which fields to include in the response. Uses defaults if not provided. See tool description for available fields and examples.')
      }).parse(params);
      
      // Use a different name for clarity if needed, or just use validatedParams.taskId
      const taskId = validatedParams.taskId;
      const fields = validatedParams.fields;

      // The manual check below is now redundant if Zod parse succeeds
      /*
      if (!taskId || typeof taskId !== 'string') {
        console.error('[MCP Server get_tasks_by_taskId] Validation Error: taskId is missing or not a string. Params:', JSON.stringify(params, null, 2));
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: [{ code: 'invalid_type', expected: 'string', received: typeof taskId, path: ['taskId'], message: 'Required' }] })
            }
          ]
        };
      }
      */
      
      const endpoint = parameterizeEndpoint('/tasks/{taskId}', { taskId: taskId });
      const apiResponseWrapper = await callApi(endpoint, 'GET');

      if (apiResponseWrapper.isError) {
        return apiResponseWrapper;
      }

      let rawTaskData;
      try {
        rawTaskData = JSON.parse(apiResponseWrapper.content[0].text);
      } catch (e) {
        console.error(`Failed to parse task data for taskId ${taskId}:`, e);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'API Response Error', details: 'Failed to parse task data' })
            }
          ],
          isError: true
        };
      }

      const processedData = selectFieldsFromData(
        rawTaskData, 
        fields, 
        GET_TASK_BY_ID_DEFAULT_FIELDS,
        GET_TASK_BY_ID_TOOL_SPECIFIC_RULES
      );

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(processedData)
          }
        ]
      };

    } catch (error) {
      console.error(`[MCP Server get_tasks_by_taskId] Handler error:`, error, 'Params raw:', JSON.stringify(params, null, 2));
      if (error instanceof z.ZodError) {
        // This will now catch errors if 'params' doesn't match the expected Zod schema
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error in handler', details: error.errors })
            }
          ]
        };
      }
      let errorMessage = 'An unexpected error occurred';
      if (error instanceof Error) {
        errorMessage = error.message;
      }
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({ error: 'Internal tool error', details: errorMessage })
          }
        ]
      };
    }
  }
);

/* Delete a Task */
registerTool(
  'delete_tasks_by_taskId',
  `Permanently deletes a task based on its \`ID\`.`,
  { // MODIFIED: Was z.object()
    taskId: z.string().describe('The ID of the task to delete.')
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        taskId: z.string().describe('The ID of the task to delete.')
      }).parse(params);
      const endpoint = parameterizeEndpoint('/tasks/{taskId}', validatedParams);
      return callApi(endpoint, 'DELETE');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

registerTool(
  'post_tasks',
  `**Overview:** Creates a new task in a specified workspace.

**Description Input:**
When passing in a task description, the input will be treated as [GitHub Flavored Markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax).

**Request Parameters:**
**Request Body Parameters:**
- **Required:** \`name\` (string), \`workspaceId\` (string)
- **Optional:** \`description\` (string), \`dueDate\` (string, YYYY-MM-DD or ISO 8601), \`duration\` (send numbers as strings like \\"30\\" for minutes, or keywords like \\"NONE\\"\\/"REMINDER\\"), \`status\` (string, status name), \`priority\` (string: "ASAP", "HIGH", "MEDIUM", "LOW"), \`assigneeId\` (string, user ID), \`projectId\` (string), \`labels\` (array of strings), \`autoScheduled\` (object or null).

**Response Format:**
On success, returns \`{ "status": "SUCCESS", "id": "<NEW_TASK_ID>" }\`.
On failure, returns \`{ "status": "FAILURE", "id": null }\`.`,
  {
    body: z.object({
      dueDate: z.string().optional().describe("Optional. Task due date in YYYY-MM-DD or ISO 8601 format."),
      duration: z.string().optional().describe("Optional. Task duration. Send numbers as strings (e.g., \"30\" for 30 minutes), or specific keywords like \"NONE\" or \"REMINDER\"."),
      status: z.string().optional().describe("Optional. Name of the status to assign the task."),
      autoScheduled: z.object({
        startDate: z.string().optional().describe("Date auto-scheduling should begin (YYYY-MM-DD or ISO 8601 format)."),
        deadlineType: z.string().optional().describe("Type of deadline (e.g., \'SOFT\', \'HARD\')."),
        schedule: z.string().optional().describe("Name or ID of the schedule to use.")
      }).nullable().optional().describe("Optional. Object to configure auto-scheduling, or null to disable. Task\'s target status must allow auto-scheduling."),
      name: z.string().describe("Required. The name/title of the task."),
      projectId: z.string().optional().describe("Optional. ID of the project to associate the task with."),
      workspaceId: z.string().describe("Required. The ID of the workspace where the task will be created."),
      description: z.string().optional().describe("Optional. Task description in GitHub Flavored Markdown."),
      priority: z.string().optional().describe("Optional. Task priority. Valid values: \'ASAP\', \'HIGH\', \'MEDIUM\', \'LOW\'. Defaults to MEDIUM if unspecified."),
      labels: z.array(z.string()).optional().describe("Optional. Array of label names to assign to the task."),
      assigneeId: z.string().optional().describe("Optional. ID of the user to assign the task to.")
    })
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        body: z.object({
          dueDate: z.string().optional().describe("Optional. Task due date in YYYY-MM-DD or ISO 8601 format."),
          duration: z.string().optional().describe("Optional. Task duration. Send numbers as strings (e.g., \"30\" for 30 minutes), or specific keywords like \"NONE\" or \"REMINDER\"."),
          status: z.string().optional().describe("Optional. Name of the status to assign the task."),
          autoScheduled: z.object({
            startDate: z.string().optional().describe("Date auto-scheduling should begin (YYYY-MM-DD or ISO 8601 format)."),
            deadlineType: z.string().optional().describe("Type of deadline (e.g., \'SOFT\', \'HARD\')."),
            schedule: z.string().optional().describe("Name or ID of the schedule to use.")
          }).nullable().optional().describe("Optional. Object to configure auto-scheduling, or null to disable. Task\'s target status must allow auto-scheduling."),
          name: z.string().describe("Required. The name/title of the task."),
          projectId: z.string().optional().describe("Optional. ID of the project to associate the task with."),
          workspaceId: z.string().describe("Required. The ID of the workspace where the task will be created."),
          description: z.string().optional().describe("Optional. Task description in GitHub Flavored Markdown."),
          priority: z.string().optional().describe("Optional. Task priority. Valid values: \'ASAP\', \'HIGH\', \'MEDIUM\', \'LOW\'. Defaults to MEDIUM if unspecified."),
          labels: z.array(z.string()).optional().describe("Optional. Array of label names to assign to the task."),
          assigneeId: z.string().optional().describe("Optional. ID of the user to assign the task to.")
        })
      }).parse(params);
      
      // Handle duration parsing for post_tasks
      let apiDuration: string | number | undefined = validatedParams.body.duration;
      if (typeof validatedParams.body.duration === 'string') {
        const numericDuration = parseInt(validatedParams.body.duration, 10);
        if (!isNaN(numericDuration) && numericDuration.toString() === validatedParams.body.duration) {
          apiDuration = numericDuration;
        } else {
          // It's a non-numeric string like "NONE" or "REMINDER", keep as is
          apiDuration = validatedParams.body.duration;
        }
      }

      const apiBody = {
        ...validatedParams.body,
        duration: apiDuration // Use the potentially parsed duration
      };

      const endpoint = parameterizeEndpoint('/tasks', {});
      const apiResponseWrapper = await callApi(endpoint, 'POST', apiBody, 'application/json');

      if (apiResponseWrapper.isError) {
        // callApi already includes error details, but PRD wants specific format for post_tasks failure
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ status: 'FAILURE', id: null })
            }
          ]
        };
      }

      // Assuming successful API call returns the created task object with an id
      let createdTaskData;
      try {
        createdTaskData = JSON.parse(apiResponseWrapper.content[0].text);
        if (createdTaskData && createdTaskData.id) {
          return {
            content: [
              {
                type: 'text',
                text: JSON.stringify({ status: 'SUCCESS', id: createdTaskData.id })
              }
            ]
          };
        } else {
          // If API success but no ID or unexpected format
          console.error('post_tasks: API success but ID missing in response', createdTaskData);
          return {
            content: [
              {
                type: 'text',
                text: JSON.stringify({ status: 'FAILURE', id: null })
              }
            ]
          };
        }
      } catch (e) {
        console.error('post_tasks: Failed to parse successful API response', e);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ status: 'FAILURE', id: null })
            }
          ]
        };
      }

    } catch (error) {
      // Handles Zod validation errors and any other unexpected errors before/after API call
      console.error('Error in post_tasks handler:', error);
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({ status: 'FAILURE', id: null })
          }
        ]
      };
    }
  }
);


registerTool(
  'get_tasks',
  `**Overview:** By default, all tasks that are completed are left out unless specifically filtered for via the status.

**Available Response Fields:**

1. **Simple Fields** (directly accessible):
   - \`id\`, \`name\`, \`description\`, \`duration\`, \`dueDate\`, \`deadlineType\`
   - \`completed\`, \`completedTime\`, \`updatedTime\`, \`startOn\`
   - \`priority\`, \`scheduledStart\`, \`scheduledEnd\`, \`schedulingIssue\`
   - \`createdTime\`, \`lastInteractedTime\`

2. **Nested Object Fields** (use dot notation):
   - \`creator.id\`, \`creator.name\`, \`creator.email\`
   - \`workspace.id\`, \`workspace.name\`, \`workspace.type\`
   - \`project.id\`, \`project.name\`, \`project.description\`, \`project.workspaceId\`
   - \`status.name\`, \`status.isDefaultStatus\`, \`status.isResolvedStatus\`

3. **Array Fields** (use array notation, see toolSpecificRules for simplifications):
   - \`assignees[].id\`, \`assignees[].name\`, \`assignees[].email\` (default simplified to name)
   - \`labels[]\` (array of strings)
   - \`chunks[].id\`, \`chunks[].duration\`, \`chunks[].scheduledStart\`, \`chunks[].scheduledEnd\`, \`chunks[].completedTime\`, \`chunks[].isFixed\`

**Examples:**
- For basic task info: \`fields=["id", "name", "status.name", "priority"]\`
- For scheduling: \`fields=["id", "scheduledStart", "scheduledEnd", "duration"]\`
- For assignee details: \`fields=["id", "name", "assignees"]\`

**Default Fields:** (when \`fields\` is omitted):
${GET_TASKS_DEFAULT_FIELDS.join(', ')}`,
  { // MODIFIED: Was z.object()
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    label: z.string().optional().describe('Limit tasks returned by label on the task'),
    status: z.array(z.string()).optional().describe('Limit tasks returned by statuses that exist on tasks, cannot specify this (\'status\')\nAND includeAllStatuses in the same request'),
    includeAllStatuses: z.boolean().optional().describe('Limit tasks returned by statuses that exist on tasks, cannot specify this (\'includeAllStatuses\')\nAND status in the same request'),
    workspaceId: z.string().optional().describe('The id of the workspace you want tasks from. If not provided, will return tasks from all workspaces the user is a member of.'),
    projectId: z.string().optional().describe('Limit tasks returned to a given project'),
    name: z.string().optional().describe('Limit tasks returned to those that contain this string. Case in-sensitive'),
    assigneeId: z.string().optional().describe('Limit tasks returned to a specific assignee'),
    fields: z.array(z.string()).optional().describe('Specify which fields to include in the response')
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        cursor: z.string().optional(),
        label: z.string().optional(),
        status: z.array(z.string()).optional().describe("Limit tasks returned by statuses that exist on tasks, cannot specify this ('status')\nAND includeAllStatuses in the same request"), // Corrected escapes
        includeAllStatuses: z.boolean().optional().describe("Limit tasks returned by statuses that exist on tasks, cannot specify this ('includeAllStatuses')\nAND status in the same request"), // Corrected escapes
        workspaceId: z.string().optional(),
        projectId: z.string().optional(),
        name: z.string().optional(),
        assigneeId: z.string().optional(),
        fields: z.array(z.string()).optional()
      }).parse(params);
      
      const { fields, ...apiParams } = validatedParams;
      
      const endpoint = parameterizeEndpoint('/tasks', apiParams);
      const apiResponseWrapper = await callApi(endpoint, 'GET');
      
      let apiResponse;
      if (apiResponseWrapper.isError) {
        return apiResponseWrapper;
      }

      if (apiResponseWrapper && 
          apiResponseWrapper.content && 
          Array.isArray(apiResponseWrapper.content) && 
          apiResponseWrapper.content[0] && 
          apiResponseWrapper.content[0].text) {
        try {
          apiResponse = JSON.parse(apiResponseWrapper.content[0].text);
        } catch (e) {
          console.error("get_tasks: Failed to parse API response", e);
          return {
            content: [
              {
                type: 'text',
                text: JSON.stringify({ error: 'API Response Error', details: 'Failed to parse tasks data.' })
              }
            ],
            isError: true
          };
        }
      } else {
        console.error("get_tasks: Invalid API response structure");
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'API Response Error', details: 'Invalid API response structure.' })
            }
          ],
          isError: true
        };
      }
      
      if (apiResponse && apiResponse.tasks && Array.isArray(apiResponse.tasks)) {
        const processedTasks = selectFieldsFromData(
          apiResponse.tasks, 
          fields, 
          GET_TASKS_DEFAULT_FIELDS, 
          GET_TASKS_TOOL_SPECIFIC_RULES
        );
        
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({
                meta: apiResponse.meta, 
                tasks: processedTasks
              })
            }
          ],
          isError: false
        };
      }
      
      
      // If we can't transform, return an empty tasks array in the right format
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              meta: apiResponse?.meta || {},
              tasks: []
            })
          }
        ],
        isError: false
      };
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* <!-- theme: warning -->

> ### Note
>
> For simplicity, use this endpoint to unassign a task
> instead of the generic update task endpoint.
> This also prevents bugs and accidental unassignments.
 */
registerTool(
  'delete_tasks_assignee',
  `**Overview:** For simplicity, use this endpoint to unassign a task instead of the generic update task endpoint. This also prevents bugs and accidental unassignments.`,
  {
    taskId: z.string().describe('The ID of the task from which the assignee will be removed.')
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    taskId: z.string().describe('The ID of the task from which the assignee will be removed.')
  }).parse(params);
      const endpoint = parameterizeEndpoint('/tasks/{taskId}/assignee', validatedParams);
      return callApi(endpoint, 'DELETE');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);


registerTool(
  'patch_tasks_move',
  `**Overview:** Moves a task to a different workspace. 

**Request Parameters:**
**Path Parameter:**
- \`taskId\` (string, required): The ID of the task to move.

**Required Body Parameters:**
- \`workspaceId\` (string): The ID of the target workspace.

**Optional Body Parameters:**
- \`assigneeId\` (string): The user ID to assign the task to in the new workspace.

**Important Notes:**
When moving tasks, the task\'s project, status, labels, and potentially other associations from the original workspace will be reset or unlinked according to Motion API behavior.`,
  {
    taskId: z.string().describe("Required. The ID of the task to move."),
    body: z.object({
      workspaceId: z.string().describe("Required. The ID of the workspace to which you want the task moved."),
      assigneeId: z.string().optional().describe("Optional. The user ID the task should be assigned to in the new workspace.")
    })
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        taskId: z.string().describe("Required. The ID of the task to move."),
        body: z.object({
          workspaceId: z.string().describe("Required. The ID of the workspace to which you want the task moved."),
          assigneeId: z.string().optional().describe("Optional. The user ID the task should be assigned to in the new workspace.")
        })
      }).parse(params);
      
      // Extraktion des taskId und body aus validatedParams
      const { taskId, body } = validatedParams;
      
      // Übergabe nur der taskId für den URL-Pfad
      const endpoint = parameterizeEndpoint('/tasks/{taskId}/move', { taskId });
      
      // Senden nur des body-Inhalts an die API
      return callApi(endpoint, 'PATCH', body, 'application/json');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* List users */
registerTool(
  'get_users',
  `**Overview:** Lists users, optionally filtered by workspace or team. Supports pagination via \`cursor\`.

The response is an object containing a \`users\` array and potentially a \`meta\` object for pagination.

**Fixed Fields:** Each user object in the array *always* contains the following fixed fields:
- \`id\`: The user\'s unique identifier.
- \`name\`: The user\'s name.
- \`email\`: The user\'s email address.

**Notes:** If more results are available, the \`meta.cursor\` field will contain a string to pass to the \`cursor\` parameter for the next page.
This tool does *not* support the \`fields\` parameter.`,
  {
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    workspaceId: z.string().optional().describe("Optional. Filter users belonging to a specific workspace ID."),
    teamId: z.string().optional().describe("Optional. Filter users belonging to a specific team ID.")
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        cursor: z.string().optional(),
        workspaceId: z.string().optional(),
        teamId: z.string().optional()
      }).parse(params);
      
      const endpoint = parameterizeEndpoint('/users', validatedParams);
      const apiResponseWrapper = await callApi(endpoint, 'GET');

      if (apiResponseWrapper.isError) {
        return apiResponseWrapper;
      }

      let rawUsersResponse;
      try {
        rawUsersResponse = JSON.parse(apiResponseWrapper.content[0].text);
      } catch (e: any) {
        console.error('Failed to parse users list data:', e.message);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'API Response Error', details: `Failed to parse users data: ${e.message}` })
            }
          ],
          isError: true
        };
      }

      let processedUsers = [];
      if (rawUsersResponse && Array.isArray(rawUsersResponse.users)) {
        processedUsers = selectFieldsFromData(
          rawUsersResponse.users, // Pass the array of users
          GET_USERS_FIXED_FIELDS,
          GET_USERS_FIXED_FIELDS
        );
      } else if (Array.isArray(rawUsersResponse)) { // If the API returns an array directly
         processedUsers = selectFieldsFromData(
          rawUsersResponse, 
          GET_USERS_FIXED_FIELDS,
          GET_USERS_FIXED_FIELDS
        );
        // In this case, there's no top-level 'meta' from the original response to preserve directly with the users array.
        // The PRD implies the response should be an object with a 'users' key.
        // So, we wrap it if it was a direct array.
         return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ users: processedUsers })
            }
          ]
        };
      }

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({ users: processedUsers, meta: rawUsersResponse.meta || {} })
          }
        ]
      };

    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      console.error('Unexpected error in get_users:', error);
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({ error: 'Internal Server Error', details: 'An unexpected error occurred' })
          }
        ],
        isError: true
      };
    }
  }
);

/* Get My User */
registerTool(
  'get_users_me',
  `**Overview:** Retrieves the profile information for the currently authenticated user (associated with the API key).
**Fixed Fields:** This tool always returns an object containing the following fixed fields:
- \`id\`: The user\'s unique identifier.
- \`name\`: The user\'s name.
- \`email\`: The user\'s email address.
**Notes:** This tool does *not* support the \`fields\` parameter.`,
  {},
  async (params) => {
    try {
      // No parameters to validate for this tool
      const endpoint = parameterizeEndpoint('/users/me', {});
      const apiResponseWrapper = await callApi(endpoint, 'GET');

      if (apiResponseWrapper.isError) {
        return apiResponseWrapper;
      }

      let rawUserData;
      try {
        rawUserData = JSON.parse(apiResponseWrapper.content[0].text);
      } catch (e: any) {
        console.error('Failed to parse current user data:', e.message);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'API Response Error', details: `Failed to parse user data: ${e.message}` })
            }
          ],
          isError: true
        };
      }

      const processedData = selectFieldsFromData(
        rawUserData,
        GET_USERS_ME_FIXED_FIELDS, // Use fixed fields as per PRD 2.5
        GET_USERS_ME_FIXED_FIELDS  // Defaults are the same as fixed fields
      );

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(processedData)
          }
        ]
      };

    } catch (error) {
      // Catching potential ZodError, though not expected here as no params are defined
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      // General error handling for unexpected issues
      console.error('Unexpected error in get_users_me:', error);
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({ error: 'Internal Server Error', details: 'An unexpected error occurred' })
          }
        ],
        isError: true
      };
    }
  }
);

/* List workspaces */
registerTool(
  'get_workspaces',
  `Lists workspaces the current user has access to. Supports filtering by specific \`ids\`, pagination via \`cursor\`, and response customization via \`fields\`.


**Available Response Fields:**

1.  **Simple Fields:** \`id\`, \`name\`, \`type\` (e.g., "INDIVIDUAL"), \`teamId\` (ID string or null).
2.  **Array Fields:**
    *   \`labels\`: An array of label strings defined for the workspace.
    *   \`taskStatuses\`: An array of status objects available in the workspace. Each object includes fields like \`name\`, \`isDefaultStatus\`, \`isResolvedStatus\`.

**Meta Object (for pagination):**
*   \`meta.cursor\`: If present, use this value in the \`cursor\` parameter of a subsequent call to fetch the next page of workspaces.

**Examples:**
- To get default info (id, name) for all workspaces: call without \`fields\`.
- To get defaults plus task statuses: \`fields: ["id", "name", "taskStatuses"]\`
- To get workspace type and labels: \`fields: ["id", "name", "type", "labels"]\`

**Default Fields** (if \`fields\` parameter is not provided):
${GET_WORKSPACES_DEFAULT_FIELDS.join(', ')}`,
  {
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    ids: z.array(z.string()).optional().describe("Optional. Filter results to include only workspaces with these specific IDs."),
    fields: z.array(z.string()).optional().describe('Optional. Specify which fields to include in the response (e.g., ["id", "name", "taskStatuses"]). Uses defaults (id, name) if not provided.')
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        cursor: z.string().optional(),
        ids: z.array(z.string()).optional(),
        fields: z.array(z.string()).optional()
      }).parse(params);
      
      // Exclude 'fields' from parameters sent to the API endpoint, as it's for local processing
      const { fields, ...apiParams } = validatedParams;

      const endpoint = parameterizeEndpoint('/workspaces', apiParams);
      const apiResponseWrapper = await callApi(endpoint, 'GET');

      if (apiResponseWrapper.isError) {
        return apiResponseWrapper;
      }

      let rawWorkspacesResponse;
      try {
        rawWorkspacesResponse = JSON.parse(apiResponseWrapper.content[0].text);
      } catch (e: any) {
        console.error('Failed to parse workspaces list data:', e.message);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'API Response Error', details: `Failed to parse workspaces data: ${e.message}` })
            }
          ],
          isError: true
        };
      }

      let processedWorkspaces = [];
      // API is expected to return an object like { workspaces: [], meta: {} }
      if (rawWorkspacesResponse && Array.isArray(rawWorkspacesResponse.workspaces)) {
        processedWorkspaces = selectFieldsFromData(
          rawWorkspacesResponse.workspaces, // Pass the array of workspaces
          fields, // User requested fields
          GET_WORKSPACES_DEFAULT_FIELDS // Default fields
          // No toolSpecificRules needed for get_workspaces as per PRD 2.7 for default/optional handling
        );
      } else if (Array.isArray(rawWorkspacesResponse)) { // Fallback if API returns array directly
        processedWorkspaces = selectFieldsFromData(
          rawWorkspacesResponse,
          fields,
          GET_WORKSPACES_DEFAULT_FIELDS
        );
        // If it was a direct array, wrap it for consistency with a 'workspaces' key
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ workspaces: processedWorkspaces })
            }
          ]
        };
      }

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({ workspaces: processedWorkspaces, meta: rawWorkspacesResponse.meta || {} })
          }
        ]
      };

    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      console.error('Unexpected error in get_workspaces:', error);
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({ error: 'Internal Server Error', details: 'An unexpected error occurred' })
          }
        ],
        isError: true
      };
    }
  }
);

const transport = new StdioServerTransport();
await server.connect(transport);
