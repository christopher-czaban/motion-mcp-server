/**
 * Generated by spectomcp.updab.com
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { z } from 'zod';

let baseUrl = 'https://api.usemotion.com/v1'; // Base URL from Swagger spec or default

const server = new McpServer({
  name: 'Motion AI Assistant',
  version: '1.0.0'
});

function parameterizeEndpoint(endpoint: string, parameters: Record<string, any>): string {
  // Handle path parameters
  let path = endpoint.replace(/\{([^}]+)\}/g, (match, paramName) => {
    const value = parameters[paramName];
    if (value === undefined || value === null) {
      throw new Error(`Missing required parameter: ${paramName}`);
    }
    return encodeURIComponent(value);
  });

  // Handle query parameters
  const queryParams = Object.entries(parameters)
    .filter(([key]) => !endpoint.includes(`{${key}}`)) // Exclude path parameters
    .filter(([_, value]) => value !== undefined && value !== null) // Exclude null/undefined values
    .map(([key, value]) => {
      if (Array.isArray(value)) {
        return value.map(v => `${encodeURIComponent(key)}=${encodeURIComponent(v)}`).join('&');
      }
      return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
    })
    .join('&');

  if (queryParams) {
    path += `?${queryParams}`;
  }

  return path;
}

async function callApi(endpoint: string, method: string, body?: any, contentType?: string) {
  const headers: Record<string, string> = {};
  if (contentType) {
    headers['Content-Type'] = contentType;
  }
  // Retrieve API key from environment variable
  const apiKey = process.env.MOTION_API_KEY;
  if (!apiKey) {
    // Return an error response if the API key is missing
    // This prevents leaking information about the missing key in thrown errors
    console.error("Error: MOTION_API_KEY environment variable not set.");
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({ error: 'Configuration error', details: 'MOTION_API_KEY environment variable not set. Please configure it in your MCP client.' })
        }
      ],
      isError: true // Indicate that this is a tool execution error
    };
  }
  headers['X-API-Key'] = apiKey; // Add the API key header

  const response = await fetch(`${baseUrl}${endpoint}`, {
    method,
    headers,
    body: body ? JSON.stringify(body) : undefined
  });
  
  // Check for non-OK responses after fetch, but before trying to parse JSON
  if (!response.ok) {
    // Attempt to read error details, but handle cases where it might not be JSON
    let errorDetails = `HTTP error! status: ${response.status}`;
    try {
        const errorData = await response.json();
        errorDetails = JSON.stringify(errorData);
    } catch (e) {
        // If response is not JSON, use the status text or default message
        errorDetails = response.statusText || errorDetails;
    }
    console.error("API call failed:", errorDetails);
    return {
        content: [
            {
                type: 'text',
                text: JSON.stringify({ error: 'API Error', details: errorDetails })
            }
        ],
        isError: true // Indicate a tool execution error
    };
  }

  // Proceed to parse JSON only if the response was ok
  const data = await response.json();
  return {
    content: [
      {
        type: 'text',
        text: JSON.stringify(data)
      }
    ]
    // No isError field means success
  };
}

function registerTool(name: string, description: string, parameters: any, handler: (params: any) => Promise<any>) {
  try {
    server.tool(name, description, parameters, handler);
  } catch (error) {
    console.error(`Failed to register tool ${name}:`, error);
  }
}

// Default tools
registerTool(
  'get_servers',
  'Get available servers from the Swagger spec',
  {},
  async () => {
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify([{"url":"https://api.usemotion.com/v1"}])
        }
      ]
    };
  }
);

registerTool(
  'set_base_url',
  'Set the base URL for API requests',
  {
    url: z.string().describe('The new base URL')
  },
  async (params) => {
    const validatedParams = z.object({ url: z.string() }).parse(params);
    baseUrl = validatedParams.url;
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({ success: true, newBaseUrl: baseUrl })
        }
      ]
    };
  }
);

/* ## Comment Content Input

When posting a comment, the content will be treated as [GitHub Flavored Markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax).
 */
registerTool(
  'post_comments',
  '## Comment Content Input\n\nWhen posting a comment, the content will be treated as [GitHub Flavored Markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax).\n',
  {
    body: z.object({
      taskId: z.string(),
      content: z.string()
    })
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    body: z.object({
      taskId: z.string(),
      content: z.string()
    })
  }).parse(params);
      const endpoint = parameterizeEndpoint('/comments', validatedParams);
      return callApi(endpoint, 'POST', validatedParams, 'application/json');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* List Comments */
registerTool(
  'get_comments',
  'List Comments',
  {
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    taskId: z.string()
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    taskId: z.string()
  }).parse(params);
      const endpoint = parameterizeEndpoint('/comments', validatedParams);
      return callApi(endpoint, 'GET');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* Retrieve Project */
registerTool(
  'get_projects_by_projectId',
  'Retrieve Project',
  {
    projectId: z.string()
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    projectId: z.string()
  }).parse(params);
      const endpoint = parameterizeEndpoint('/projects/{projectId}', validatedParams);
      return callApi(endpoint, 'GET');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* List Projects */
registerTool(
  'get_projects',
  'List Projects',
  {
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    workspaceId: z.string()
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    workspaceId: z.string()
  }).parse(params);
      const endpoint = parameterizeEndpoint('/projects', validatedParams);
      return callApi(endpoint, 'GET');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* Create Project */
registerTool(
  'post_projects',
  'Create Project',
  {
    body: z.object({
      dueDate: z.string().optional(),
      name: z.string(),
      workspaceId: z.string(),
      description: z.string().optional(),
      labels: z.array(z.string()).optional().describe('Defaults to MEDIUM. Options are ASAP, HIGH, MEDIUM, and LOW.'),
      status: z.string().optional(),
      priority: z.string()
    })
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        body: z.object({
          dueDate: z.string().optional(),
          name: z.string(),
          workspaceId: z.string(),
          description: z.string().optional(),
          labels: z.array(z.string()).optional(),
          status: z.string().optional(),
          priority: z.string()
        })
      }).parse(params);
      
      // Extraktion des body-Inhalts
      const { body } = validatedParams;
      
      // Leeres Objekt für Query-Parameter
      const endpoint = parameterizeEndpoint('/projects', {});
      
      // Senden nur des body-Inhalts an die API
      const response = await callApi(endpoint, 'POST', body, 'application/json');
      
      // Prüfen, ob die Antwort einen Fehler anzeigt
      if (response.isError) {
        // Vereinfachte Fehlerantwort zurückgeben
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ status: 'FAILURE', id: null })
            }
          ]
        };
      }
      
      // ID aus der erfolgreichen Antwort extrahieren
      // response.content[0].text enthält den JSON-String des erstellten Projekts
      try {
        const projectData = JSON.parse(response.content[0].text);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ status: 'SUCCESS', id: projectData.id })
            }
          ]
        };
      } catch (error) {
        // Bei Parsing-Fehler Misserfolg zurückgeben
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ status: 'FAILURE', id: null })
            }
          ]
        };
      }
    } catch (error) {
      if (error instanceof z.ZodError) {
        // Auch bei Validierungsfehlern das vereinfachte Format verwenden
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ status: 'FAILURE', id: null })
            }
          ]
        };
      }
      
      // Für alle anderen Fehler ebenfalls vereinfachte Fehlerantwort
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({ status: 'FAILURE', id: null })
          }
        ]
      };
    }
  }
);

/* ## Description Input

When passing in a task description, the input will be treated as [GitHub Flavored Markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax).

# Defining Frequencies

In order to give our API all the power that motion has to offer, we allow calls to create recurring tasks in the same way you can through the UI.

## Defining specific days for a frequency

<!-- theme: warning -->

> ### Note
>
> Defining days should always be used along with a specific frequency type as defined below.
> A array of days should never be used on its own. See examples below.

When picking a set of specific week days, we expect it to be defined as an array with a subset of the following values.

- MO - Monday
- TU - Tuesday
- WE - Wednesday
- TH - Thursday
- FR - Friday
- SA - Saturday
- SU - Sunday

Example - `[MO, FR, SU]` would mean Monday, Friday and Sunday.

## Defining a daily frequency

- `daily_every_day`
- `daily_every_week_day`
- `daily_specific_days_$DAYS_ARRAY$`
  - Ex: `daily_specific_days_[MO, TU, FR]`

## Defining a weekly frequency

- `weekly_any_day`
- `weekly_any_week_day`
- `weekly_specific_days_$DAYS_ARRAY$`
  - Ex: `weekly_specific_days_[MO, TU, FR]`

## Defining a bi-weekly frequency

- `biweekly_first_week_specific_days_$DAYS_ARRAY$`
  - Ex: `biweekly_first_week_specific_days_[MO, TU, FR]`
- `biweekly_first_week_any_day`
- `biweekly_first_week_any_week_day`
- `biweekly_second_week_any_day`
- `biweekly_second_week_any_week_day`

## Defining a monthly frequency

### Specific Week Day Options

When choosing the 1st, 2nd, 3rd, 4th or last day of the week for the month, it takes the form of any of the following where $DAY$ can be substituted for the day code mentioned above.

- `monthly_first_$DAY$`
- `monthly_second_$DAY$`
- `monthly_third_$DAY$`
- `monthly_fourth_$DAY$`
- `monthly_last_$DAY$`

**Example**
`monthly_first_MO`

### Specific Day Options

When choosing a specific day of the month, for example the 6th, it would be defined with just the number like below.

Examples:

- `monthly_1`
- `monthly_15`
- `monthly_31`

In the case you choose a numeric value for a month that does not have that many days, we will default to the last day of the month.

### Specific Week Options

**Any Day**

- `monthly_any_day_first_week`
- `monthly_any_day_second_week`
- `monthly_any_day_third_week`
- `monthly_any_day_fourth_week`
- `monthly_any_day_last_week`

**Any Week Day**

- `monthly_any_week_day_first_week`
- `monthly_any_week_day_second_week`
- `monthly_any_week_day_third_week`
- `monthly_any_week_day_fourth_week`
- `monthly_any_week_day_last_week`

### Other Options

- `monthly_last_day_of_month`
- `monthly_any_week_day_of_month`
- `monthly_any_day_of_month`

## Defining a quarterly frequency

### First Days

- `quarterly_first_day`
- `quarterly_first_week_day`
- `quarterly_first_$DAY$`
  - Ex. `quarterly_first_MO`

### Last Days

- `quarterly_last_day`
- `quarterly_last_week_day`
- `quarterly_last_$DAY$`
  - Ex. `quarterly_last_MO`

### Other Options

- `quarterly_any_day_first_week`
- `quarterly_any_day_second_week`
- `quarterly_any_day_last_week`
- `quarterly_any_day_first_month`
- `quarterly_any_day_second_month`
- `quarterly_any_day_third_month`
 */
registerTool(
  'post_recurring-tasks',
  '## Description Input\n\nWhen passing in a task description, the input will be treated as [GitHub Flavored Markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax).\n\n# Defining Frequencies\n\nIn order to give our API all the power that motion has to offer, we allow calls to create recurring tasks in the same way you can through the UI.\n\n## Defining specific days for a frequency\n\n<!-- theme: warning -->\n\n> ### Note\n>\n> Defining days should always be used along with a specific frequency type as defined below.\n> A array of days should never be used on its own. See examples below.\n\nWhen picking a set of specific week days, we expect it to be defined as an array with a subset of the following values.\n\n- MO - Monday\n- TU - Tuesday\n- WE - Wednesday\n- TH - Thursday\n- FR - Friday\n- SA - Saturday\n- SU - Sunday\n\nExample - `[MO, FR, SU]` would mean Monday, Friday and Sunday.\n\n## Defining a daily frequency\n\n- `daily_every_day`\n- `daily_every_week_day`\n- `daily_specific_days_$DAYS_ARRAY$`\n  - Ex: `daily_specific_days_[MO, TU, FR]`\n\n## Defining a weekly frequency\n\n- `weekly_any_day`\n- `weekly_any_week_day`\n- `weekly_specific_days_$DAYS_ARRAY$`\n  - Ex: `weekly_specific_days_[MO, TU, FR]`\n\n## Defining a bi-weekly frequency\n\n- `biweekly_first_week_specific_days_$DAYS_ARRAY$`\n  - Ex: `biweekly_first_week_specific_days_[MO, TU, FR]`\n- `biweekly_first_week_any_day`\n- `biweekly_first_week_any_week_day`\n- `biweekly_second_week_any_day`\n- `biweekly_second_week_any_week_day`\n\n## Defining a monthly frequency\n\n### Specific Week Day Options\n\nWhen choosing the 1st, 2nd, 3rd, 4th or last day of the week for the month, it takes the form of any of the following where $DAY$ can be substituted for the day code mentioned above.\n\n- `monthly_first_$DAY$`\n- `monthly_second_$DAY$`\n- `monthly_third_$DAY$`\n- `monthly_fourth_$DAY$`\n- `monthly_last_$DAY$`\n\n**Example**\n`monthly_first_MO`\n\n### Specific Day Options\n\nWhen choosing a specific day of the month, for example the 6th, it would be defined with just the number like below.\n\nExamples:\n\n- `monthly_1`\n- `monthly_15`\n- `monthly_31`\n\nIn the case you choose a numeric value for a month that does not have that many days, we will default to the last day of the month.\n\n### Specific Week Options\n\n**Any Day**\n\n- `monthly_any_day_first_week`\n- `monthly_any_day_second_week`\n- `monthly_any_day_third_week`\n- `monthly_any_day_fourth_week`\n- `monthly_any_day_last_week`\n\n**Any Week Day**\n\n- `monthly_any_week_day_first_week`\n- `monthly_any_week_day_second_week`\n- `monthly_any_week_day_third_week`\n- `monthly_any_week_day_fourth_week`\n- `monthly_any_week_day_last_week`\n\n### Other Options\n\n- `monthly_last_day_of_month`\n- `monthly_any_week_day_of_month`\n- `monthly_any_day_of_month`\n\n## Defining a quarterly frequency\n\n### First Days\n\n- `quarterly_first_day`\n- `quarterly_first_week_day`\n- `quarterly_first_$DAY$`\n  - Ex. `quarterly_first_MO`\n\n### Last Days\n\n- `quarterly_last_day`\n- `quarterly_last_week_day`\n- `quarterly_last_$DAY$`\n  - Ex. `quarterly_last_MO`\n\n### Other Options\n\n- `quarterly_any_day_first_week`\n- `quarterly_any_day_second_week`\n- `quarterly_any_day_last_week`\n- `quarterly_any_day_first_month`\n- `quarterly_any_day_second_month`\n- `quarterly_any_day_third_month`\n',
  {
    body: z.object({
      frequency: z.string(),
      deadlineType: z.string().optional(),
      duration: z.any().optional(),
      startingOn: z.string().optional(),
      idealTime: z.string().optional(),
      schedule: z.string().optional(),
      name: z.string(),
      workspaceId: z.string(),
      description: z.string().optional(),
      priority: z.string(),
      assigneeId: z.string()
    })
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        body: z.object({
          frequency: z.string(),
          deadlineType: z.string().optional(),
          duration: z.any().optional(),
          startingOn: z.string().optional(),
          idealTime: z.string().optional(),
          schedule: z.string().optional(),
          name: z.string(),
          workspaceId: z.string(),
          description: z.string().optional(),
          priority: z.string(),
          assigneeId: z.string()
        })
      }).parse(params);
      
      // Extraktion des body-Inhalts
      const { body } = validatedParams;
      
      // Leeres Objekt für Query-Parameter
      const endpoint = parameterizeEndpoint('/recurring-tasks', {});
      
      // Senden nur des body-Inhalts an die API
      return callApi(endpoint, 'POST', body, 'application/json');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* List Recurring Tasks */
registerTool(
  'get_recurring-tasks',
  'List Recurring Tasks',
  {
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    workspaceId: z.string().describe('The id of the workspace you want tasks from.')
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    workspaceId: z.string().describe('The id of the workspace you want tasks from.')
  }).parse(params);
      const endpoint = parameterizeEndpoint('/recurring-tasks', validatedParams);
      return callApi(endpoint, 'GET');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* Delete a Recurring Task */
registerTool(
  'delete_recurring-tasks_by_taskId',
  'Delete a Recurring Task',
  {
    taskId: z.string()
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    taskId: z.string()
  }).parse(params);
      const endpoint = parameterizeEndpoint('/recurring-tasks/{taskId}', validatedParams);
      return callApi(endpoint, 'DELETE');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* Get a list of schedules for your user */
registerTool(
  'get_schedules',
  'Get a list of schedules for your user',
  {},
  async (params) => {
    try {
      const validatedParams = z.object({}).parse(params);
      const endpoint = parameterizeEndpoint('/schedules', validatedParams);
      return callApi(endpoint, 'GET');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* List statuses for a workspace */
registerTool(
  'get_statuses',
  'List statuses for a workspace',
  {
    workspaceId: z.string()
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    workspaceId: z.string()
  }).parse(params);
      const endpoint = parameterizeEndpoint('/statuses', validatedParams);
      return callApi(endpoint, 'GET');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* Update a Task */
registerTool(
  'patch_tasks_by_taskId',
  'Update a Task',
  {
    taskId: z.string(),
    body: z.object({
      name: z.string().optional(),
      dueDate: z.string().optional(),
      assigneeId: z.string().nullable().optional(),
      duration: z.any().optional(),
      status: z.string().optional(),
      autoScheduled: z.object({
        startDate: z.string().optional(),
        deadlineType: z.string().optional(),
        schedule: z.string().optional()
      }).nullable().optional(),
      projectId: z.string().optional(),
      description: z.string().optional(),
      priority: z.string().optional(),
      labels: z.array(z.string()).optional()
    })
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        taskId: z.string(),
        body: z.object({
          name: z.string().optional(),
          dueDate: z.string().optional(),
          assigneeId: z.string().nullable().optional(),
          duration: z.any().optional(),
          status: z.string().optional(),
          autoScheduled: z.object({
            startDate: z.string().optional(),
            deadlineType: z.string().optional(),
            schedule: z.string().optional()
          }).nullable().optional(),
          projectId: z.string().optional(),
          description: z.string().optional(),
          priority: z.string().optional(),
          labels: z.array(z.string()).optional()
        })
      }).parse(params);
      
      // Extrahiere taskId und body aus validatedParams
      const { taskId, body } = validatedParams;
      
      // Verwende taskId für die URL-Pfad-Parameter
      const endpoint = parameterizeEndpoint('/tasks/{taskId}', { taskId });
      
      // Sende nur den body-Inhalt an die API
      return callApi(endpoint, 'PATCH', body, 'application/json');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* Retrieve a Task */
registerTool(
  'get_tasks_by_taskId',
  'Retrieve a Task',
  {
    taskId: z.string()
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    taskId: z.string()
  }).parse(params);
      const endpoint = parameterizeEndpoint('/tasks/{taskId}', validatedParams);
      return callApi(endpoint, 'GET');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* Delete a Task */
registerTool(
  'delete_tasks_by_taskId',
  'Delete a Task',
  {
    taskId: z.string()
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    taskId: z.string()
  }).parse(params);
      const endpoint = parameterizeEndpoint('/tasks/{taskId}', validatedParams);
      return callApi(endpoint, 'DELETE');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* ## Description Input

When passing in a task description, the input will be treated as [GitHub Flavored Markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax).

registerTool(
  'post_tasks',
  '## Description Input\n\nWhen passing in a task description, the input will be treated as [GitHub Flavored Markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax).\n',
  {
    body: z.object({
      dueDate: z.string().optional(),
      duration: z.any().optional(),
      status: z.string().optional(),
      autoScheduled: z.object({
      startDate: z.string().optional(),
      deadlineType: z.string().optional(),
      schedule: z.string().optional()
    }).nullable().optional(),
      name: z.string(),
      projectId: z.string().optional(),
      workspaceId: z.string(),
      description: z.string().optional(),
      priority: z.string().optional(),
      labels: z.array(z.string()).optional(),
      assigneeId: z.string().optional()
    })
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    body: z.object({
      dueDate: z.string().optional(),
      duration: z.any().optional(),
      status: z.string().optional(),
      autoScheduled: z.object({
      startDate: z.string().optional(),
      deadlineType: z.string().optional(),
      schedule: z.string().optional()
    }).nullable().optional(),
      name: z.string(),
      projectId: z.string().optional(),
      workspaceId: z.string(),
      description: z.string().optional(),
      priority: z.string().optional(),
      labels: z.array(z.string()).optional(),
      assigneeId: z.string().optional()
    })
  }).parse(params);
      const endpoint = parameterizeEndpoint('/tasks', validatedParams);
      return callApi(endpoint, 'POST', validatedParams, 'application/json');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);
 */
registerTool(
  'post_tasks',
  '## Description Input\n\nWhen passing in a task description, the input will be treated as [GitHub Flavored Markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax).\n',
  {
    body: z.object({
      dueDate: z.string().optional(),
      duration: z.any().optional(),
      status: z.string().optional(),
      autoScheduled: z.object({
        startDate: z.string().optional(),
        deadlineType: z.string().optional(),
        schedule: z.string().optional()
      }).nullable().optional(),
      name: z.string(),
      projectId: z.string().optional(),
      workspaceId: z.string(),
      description: z.string().optional(),
      priority: z.string().optional(),
      labels: z.array(z.string()).optional(),
      assigneeId: z.string().optional()
    })
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        body: z.object({
          dueDate: z.string().optional(),
          duration: z.any().optional(),
          status: z.string().optional(),
          autoScheduled: z.object({
            startDate: z.string().optional(),
            deadlineType: z.string().optional(),
            schedule: z.string().optional()
          }).nullable().optional(),
          name: z.string(),
          projectId: z.string().optional(),
          workspaceId: z.string(),
          description: z.string().optional(),
          priority: z.string().optional(),
          labels: z.array(z.string()).optional(),
          assigneeId: z.string().optional()
        })
      }).parse(params);
      
      // Use empty object for query parameters since we're sending everything in the body
      const endpoint = parameterizeEndpoint('/tasks', {});
      
      // Pass only the body content to callApi, not the entire validatedParams
      return callApi(endpoint, 'POST', validatedParams.body, 'application/json');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* <!-- theme: warning -->

> ### Note
>
> By default, all tasks that are completed are left out unless
> specifically filtered for via the status.

registerTool(
  'get_tasks',
  '<!-- theme: warning -->\n\n> ### Note\n>\n> By default, all tasks that are completed are left out unless\n> specifically filtered for via the status.\n',
  {
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    label: z.string().optional().describe('Limit tasks returned by label on the task'),
    status: z.array(z.string()).optional().describe('Limit tasks returned by statuses that exist on tasks, cannot specify this (\'status\')\nAND includeAllStatuses in the same request'),
    includeAllStatuses: z.boolean().optional().describe('Limit tasks returned by statuses that exist on tasks, cannot specify this (\'includeAllStatuses\')\nAND status in the same request'),
    workspaceId: z.string().optional().describe('The id of the workspace you want tasks from. If not provided, will return tasks from all workspaces the user is a member of.'),
    projectId: z.string().optional().describe('Limit tasks returned to a given project'),
    name: z.string().optional().describe('Limit tasks returned to those that contain this string. Case in-sensitive'),
    assigneeId: z.string().optional().describe('Limit tasks returned to a specific assignee')
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    label: z.string().optional().describe('Limit tasks returned by label on the task'),
    status: z.array(z.string()).optional().describe('Limit tasks returned by statuses that exist on tasks, cannot specify this (\'status\')\nAND includeAllStatuses in the same request'),
    includeAllStatuses: z.boolean().optional().describe('Limit tasks returned by statuses that exist on tasks, cannot specify this (\'includeAllStatuses\')\nAND status in the same request'),
    workspaceId: z.string().optional().describe('The id of the workspace you want tasks from. If not provided, will return tasks from all workspaces the user is a member of.'),
    projectId: z.string().optional().describe('Limit tasks returned to a given project'),
    name: z.string().optional().describe('Limit tasks returned to those that contain this string. Case in-sensitive'),
    assigneeId: z.string().optional().describe('Limit tasks returned to a specific assignee')
  }).parse(params);
      const endpoint = parameterizeEndpoint('/tasks', validatedParams);
      return callApi(endpoint, 'GET');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);
 */

registerTool(
  'get_tasks',
  `<!-- theme: warning -->

> ### Note
>
> By default, all tasks that are completed are left out unless specifically filtered for via the status.

**Available Response Fields:**

1. **Simple Fields** (directly accessible):
   - id, name, description, duration, dueDate, deadlineType
   - completed, completedTime, updatedTime, startOn
   - priority, scheduledStart, scheduledEnd, schedulingIssue
   - createdTime, lastInteractedTime

2. **Nested Object Fields** (use dot notation):
   - creator.id, creator.name, creator.email
   - workspace.id, workspace.name, workspace.type
   - project.id, project.name, project.description, project.workspaceId
   - status.name, status.isDefaultStatus, status.isResolvedStatus

3. **Array Fields** (use array notation):
   - assignees[].id, assignees[].name, assignees[].email
   - workspace.statuses[].name, workspace.statuses[].isDefaultStatus

**Examples:**
- For basic task info: fields=["id", "name", "status.name", "priority"]
- For scheduling: fields=["id", "scheduledStart", "scheduledEnd", "duration"]
- For assignee details: fields=["id", "name", "assignees[].name"]

**Default Fields** (if none specified):
id, name, status.name, priority, dueDate, scheduledStart, scheduledEnd, duration, completed, project.name`,
  {
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    label: z.string().optional().describe('Limit tasks returned by label on the task'),
    status: z.array(z.string()).optional().describe('Limit tasks returned by statuses that exist on tasks, cannot specify this (\'status\')\nAND includeAllStatuses in the same request'),
    includeAllStatuses: z.boolean().optional().describe('Limit tasks returned by statuses that exist on tasks, cannot specify this (\'includeAllStatuses\')\nAND status in the same request'),
    workspaceId: z.string().optional().describe('The id of the workspace you want tasks from. If not provided, will return tasks from all workspaces the user is a member of.'),
    projectId: z.string().optional().describe('Limit tasks returned to a given project'),
    name: z.string().optional().describe('Limit tasks returned to those that contain this string. Case in-sensitive'),
    assigneeId: z.string().optional().describe('Limit tasks returned to a specific assignee'),
    fields: z.array(z.string()).optional().describe('Specify which fields to include in the response')
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        cursor: z.string().optional(),
        label: z.string().optional(),
        status: z.array(z.string()).optional(),
        includeAllStatuses: z.boolean().optional(),
        workspaceId: z.string().optional(),
        projectId: z.string().optional(),
        name: z.string().optional(),
        assigneeId: z.string().optional(),
        fields: z.array(z.string()).optional()
      }).parse(params);
      
      // Remove fields parameter from API call params
      const { fields, ...apiParams } = validatedParams;
      
      const endpoint = parameterizeEndpoint('/tasks', apiParams);
      const apiResponseWrapper = await callApi(endpoint, 'GET');
      
      // Extract the actual API response data from the wrapper
      let apiResponse;
      if (apiResponseWrapper && 
          apiResponseWrapper.content && 
          Array.isArray(apiResponseWrapper.content) && 
          apiResponseWrapper.content[0] && 
          apiResponseWrapper.content[0].text) {
        try {
          // This is the critical fix - properly extract the JSON data from the response
          apiResponse = JSON.parse(apiResponseWrapper.content[0].text);
        } catch (e) {
          // If parsing fails, return the original response
          return apiResponseWrapper;
        }
      } else if (apiResponseWrapper.isError) {
        // If there was an error, return it
        return apiResponseWrapper;
      } else {
        // If format doesn't match expectations, return original
        return apiResponseWrapper;
      }
      
      // Define default fields if none specified - using correct dot notation
      const defaultFields = [
        'id', 
        'name', 
        'status.name', 
        'priority', 
        'dueDate', 
        'scheduledStart', 
        'scheduledEnd', 
        'duration', 
        'completed', 
        'project.name'
      ];
      
      // Use provided fields or defaults
      const requestedFields = fields || defaultFields;
      
      // Check if we have a valid response with tasks
      if (apiResponse && apiResponse.tasks && Array.isArray(apiResponse.tasks)) {
        const transformedTasks = apiResponse.tasks.map(task => {
          // Create empty transformed task object
          const transformedTask = {};
          
          // Process each requested field
          requestedFields.forEach(field => {
            // Handle array access notation (e.g., "assignees[].name")
            if (field.includes('[]')) {
              const [arrayPath, propPath] = field.split('[].');
              
              // Get the array using path navigation if it's a nested path
              let arrayObj = task;
              const arrayPathParts = arrayPath.split('.');
              
              // Navigate to the array object
              for (const part of arrayPathParts) {
                if (arrayObj && typeof arrayObj === 'object' && part in arrayObj) {
                  arrayObj = arrayObj[part];
                } else {
                  arrayObj = null;
                  break;
                }
              }
              
              // Process array if it exists
              if (arrayObj && Array.isArray(arrayObj)) {
                // Extract the named property from each array item
                transformedTask[field] = arrayObj.map(item => {
                  if (item && typeof item === 'object') {
                    // Handle nested properties in array items
                    if (propPath.includes('.')) {
                      const propParts = propPath.split('.');
                      let propValue = item;
                      
                      for (const part of propParts) {
                        if (propValue && typeof propValue === 'object' && part in propValue) {
                          propValue = propValue[part];
                        } else {
                          propValue = null;
                          break;
                        }
                      }
                      
                      return propValue;
                    }
                    
                    // Simple property on array item
                    return propPath in item ? item[propPath] : null;
                  }
                  return null;
                });
              } else {
                transformedTask[field] = [];
              }
              return;
            }
            
            // Handle dot notation for nested fields (including default fields)
            if (field.includes('.')) {
              const parts = field.split('.');
              let current = task;
              let valid = true;
              
              // Navigate through the object hierarchy
              for (let i = 0; i < parts.length - 1; i++) {
                if (current && typeof current === 'object' && parts[i] in current) {
                  current = current[parts[i]];
                } else {
                  valid = false;
                  break;
                }
              }
              
              // If we successfully navigated, get the final value
              if (valid && current && typeof current === 'object') {
                const finalPart = parts[parts.length - 1];
                if (finalPart in current) {
                  // Preserve the original field name with dots
                  transformedTask[field] = current[finalPart];
                } else {
                  transformedTask[field] = null;
                }
              } else {
                transformedTask[field] = null;
              }
              return;
            }
            
            // Handle regular fields
            if (field in task) {
              // Special formatting for dates in default mode
              if (field === 'dueDate' && !fields && task[field]) {
                transformedTask[field] = String(task[field]).split('T')[0];
              } else {
                transformedTask[field] = task[field];
              }
            } else {
              transformedTask[field] = null;
            }
          });
          
          return transformedTask;
        });
        
        // Return the transformed response in the expected format
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({
                meta: apiResponse.meta,
                tasks: transformedTasks
              })
            }
          ],
          isError: false
        };
      }
      
      // If we can't transform, return an empty tasks array in the right format
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              meta: apiResponse?.meta || {},
              tasks: []
            })
          }
        ],
        isError: false
      };
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ],
          isError: true
        };
      }
      throw error;
    }
  }
);

/* <!-- theme: warning -->

> ### Note
>
> For simplicity, use this endpoint to unassign a task
> instead of the generic update task endpoint.
> This also prevents bugs and accidental unassignments.
 */
registerTool(
  'delete_tasks_assignee',
  '<!-- theme: warning -->\n\n> ### Note\n>\n> For simplicity, use this endpoint to unassign a task\n> instead of the generic update task endpoint.\n> This also prevents bugs and accidental unassignments.\n',
  {
    taskId: z.string()
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    taskId: z.string()
  }).parse(params);
      const endpoint = parameterizeEndpoint('/tasks/{taskId}/assignee', validatedParams);
      return callApi(endpoint, 'DELETE');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* ### Notes
When moving tasks from one workspace to another,
the tasks project, status, and label(s) and assignee will all be reset
 */
/* ### Notes
When moving tasks from one workspace to another,
the tasks project, status, and label(s) and assignee will all be reset
 */
registerTool(
  'patch_tasks_move',
  '### Notes\n\nWhen moving tasks from one workspace to another,\nthe tasks project, status, and label(s) and assignee will all be reset\n',
  {
    taskId: z.string(),
    body: z.object({
      workspaceId: z.string(),
      assigneeId: z.string().optional()
    })
  },
  async (params) => {
    try {
      const validatedParams = z.object({
        taskId: z.string(),
        body: z.object({
          workspaceId: z.string(),
          assigneeId: z.string().optional()
        })
      }).parse(params);
      
      // Extraktion des taskId und body aus validatedParams
      const { taskId, body } = validatedParams;
      
      // Übergabe nur der taskId für den URL-Pfad
      const endpoint = parameterizeEndpoint('/tasks/{taskId}/move', { taskId });
      
      // Senden nur des body-Inhalts an die API
      return callApi(endpoint, 'PATCH', body, 'application/json');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* List users */
registerTool(
  'get_users',
  'List users',
  {
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    workspaceId: z.string().optional(),
    teamId: z.string().optional()
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    workspaceId: z.string().optional(),
    teamId: z.string().optional()
  }).parse(params);
      const endpoint = parameterizeEndpoint('/users', validatedParams);
      return callApi(endpoint, 'GET');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* Get My User */
registerTool(
  'get_users_me',
  'Get My User',
  {},
  async (params) => {
    try {
      const validatedParams = z.object({}).parse(params);
      const endpoint = parameterizeEndpoint('/users/me', validatedParams);
      return callApi(endpoint, 'GET');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

/* List workspaces */
registerTool(
  'get_workspaces',
  'List workspaces',
  {
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    ids: z.array(z.string()).optional()
  },
  async (params) => {
    try {
      const validatedParams = z.object({
    cursor: z.string().optional().describe('Use if a previous request returned a cursor. Will page through results'),
    ids: z.array(z.string()).optional()
  }).parse(params);
      const endpoint = parameterizeEndpoint('/workspaces', validatedParams);
      return callApi(endpoint, 'GET');
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ error: 'Validation error', details: error.errors })
            }
          ]
        };
      }
      throw error;
    }
  }
);

const transport = new StdioServerTransport();
await server.connect(transport);
